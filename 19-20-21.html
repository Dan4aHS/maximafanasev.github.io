<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python практика</title>
	<link rel="icon" href="img/favicon.ico">
	<link rel="stylesheet" href="style.css">
</head>

<body>
	<div class="wrapper">
		<span>&#60; </span><a href="index.html">Вернуться к списку задач</a>
		<h1>Решение 19-20-21 задач</h1>

		<h2>Из чего состоит алгоритм</h2>
		<pre>
1. m%2 == 0
2. m == 0
3. m%2 != 0
4. h = [f(), f()]
4. any(h)
5. all(h)
6. [s for s in range() if not f() and f()]</pre>

		<h2>Алгоритм для 1й кучи</h2>
	
		<pre>
def f(a, m):
 if a >= <b>___</b>: return m%2 == 0
 if m == 0: return 0
 h = [f(a<b>__</b>, m-1), f(a<b>__</b>, m-1)]
 return any(h) if m%2!=0 else all(h)

print([s for s in range(1,<b>___</b>) if f(s,2)])
print([s for s in range(1,<b>___</b>) if not f(s,1) and f(s,3)])
print([s for s in range(1,<b>___</b>) if not f(s,2) and f(s,4)])</pre>


		<h2>Алгоритм для 2х куч</h2>
<pre>
def f(a, <b>b</b>, m):
 if <b>a + b</b> >= <b>___</b>: return m%2 == 0
 if m == 0: return 0
 h = [f(a<b>__</b>, b, m-1), f(a<b>__</b>,b,m-1), f(a, b<b>__</b>,m-1), f(a, b<b>__</b>, m-1)]
 return any(h) if m%2!=0 else all(h)
 
print([s for s in range(<b>____</b>, <b>____</b>) if f(<b>____</b>, s, 2)])
print([s for s in range(<b>____</b>, <b>____</b>) if not f(<b>____</b>, s, 1) and f(<b>____</b>,s,3)])
print([s for s in range(<b>____</b>, <b>____</b>) if not f(<b>____</b>, s, 2) and f(<b>____</b>,s,4)])</pre>


		<h2>(1 тип) 1 куча камней, победа</h2>

		<p>19. Первый ход делает Петя. <b>+3 или *5. Победа при >=301</b>
		</p>
		<p>MIN S когда Ваня выигрывает первым при любом ходе Пети</p>

		<p>20. 2 MIN S</p>
		<p>– Петя не может выиграть за один ход</p>
		<p>– Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня</p>

		<p>21. MIN S</p>
		<p>– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети</p>
		<p>– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом</p>
		
		<table>
			<tr>
				<td>>=301</td>
				<td>a >= 301</td>
			</tr>
			<tr>
				<td>>=301</td>
				<td>range(1,301)</td>
			</tr>
		</table>
		<pre>
def f(a, m):
 if a >= <b>301</b>: return m%2 == 0
 if m == 0: return 0
 h = [f(a+3, m-1), f(a*5, m-1)]
 return any(h) if m%2!=0 else all(h)

print([s for s in range(<b>1,301</b>) if f(s,2)])
print([s for s in range(<b>1,301</b>) if <b>not f(s,1)</b> and f(s,3)])
print([s for s in range(<b>1,301</b>) if <b>not f(s,2)</b> and f(s,4)])

[58, 59, 60]
[12, 55, 56, 57]
[52, 53, 54]</pre>


		<h2>(2 тип) 1 куча камней, проигрыш</h2>

		<p>19. Первый ход делает Петя. <b>+2 или *3</b>. Игра завершится, когда будет <b>не менее 45, Если не более 112 то последний ход победный. Более 112 - проигрыш</b> 
		</p>
		<p>MIN S когда Ваня выигрывает первым при любом ходе Пети</p>

		<p>20. Сколько значений?</p>
		<p>– Петя не может выиграть за один ход</p>
		<p>– Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня</p>

		<p>21.MIN, MAX
		</p>
		<p>– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети</p>
		<p>– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом</p>

		<table>
			<tr>
				<td>112 >= a >= 45</td>
				<td>112 >= a >= 45</td>
			</tr>
			<tr>
				<td>> 112</td>
				<td>a > 112: m%2!=0</td>
			</tr>
		</table>
		<pre>
def f(a, m):
 if <b>45 &#60;= a &#60;= 112</b>: return m%2 == 0
 if <b>a > 112</b>: return m%2!=0
 if m == 0: return 0
 h = [f(a+2, m-1), f(a*3, m-1)]
 return any(h) if m%2!=0 else all(h)

print([s for s in range(1, 45) if f(s,2)])
print([s for s in range(1, 45) if not f(s, 1) and f(s, 3)])
print([s for s in range(1, 45) if  not f(s, 2) and f(s, 4)])

[41, 42]
[14, 39, 40]
[12, 13, 38]</pre>


		<h2>(3 тип) 2 кучи камней, неудачный первый ход Пети</h2>

		<p>19. Первый ход делает Петя. <b>+1 или *3</b>. Игра завершится, когда <b>в двух кучах будет не менее 45. В 1й куче 4 камня, во второй 1 &#60;= s &#60;= 40</b>
		</p>
		<p>MIN S Ваня выйграл после <b>неудачного хода</b></p>

		<p>20. Найти 2 значения
		</p>
		<p>– Петя не может выиграть за один ход</p>
		<p>– Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня</p>

		<p>21. Найти S
		</p>
		<p>– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети</p>
		<p>– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом</p>

		<p><b>19. all меняем на any в коде, чтобы найти хотябы 1 победу</b></p>
		
		<table>
			<tr>
				<td>/ 2</td>
				<td>(a+1)//2</td>
			</tr>
			<tr>
				<td>>= 45</td>
				<td>a + b >= 45</td>
			</tr>
			<tr>
				<td>в первой куче 10</td>
				<td>f(10,s,_)</td>
			</tr>
			<tr>
				<td>вторая куча > 10</td>
				<td>range(11,1000)</td>
			</tr>
		</table>
		
		
		<pre>
def f(a, b, m):
 if a + b >= 45: return m%2 == 0
 if m == 0: return 0
 h = [f(a+1, b, m-1), f(a*3,b,m-1), f(a, b+1,m-1), f(a, b*3, m-1)]
 return any(h) if m%2!=0 else <b>any</b>(h)
 
print([s for s in range(1, 41) if f(4, s, 2)])
		
[5]</pre>

		<p><b>20. 21. any меняем на all</b></p>
		<pre>
def f(a, b, m):
 if a + b >= 45: return m%2 == 0
 if m == 0: return 0
 h = [f(a+1, b, m-1), f(a*3,b,m-1), f(a, b+1,m-1), f(a, b*3, m-1)]
 return any(h) if m%2!=0 else <b>all</b>(h)
 
print([s for s in range(1, 41) if not f(<b>4, s, 1</b>) and f(<b>4,s,3</b>)])
print([s for s in range(1, 41) if not f(<b>4, s, 2</b>) and f(<b>4,s,4</b>)])

[8, 13]
[12]</pre>



		<h2>(4 тип) 2 кучи камней, с уменьшением</h2>

		<p>19. Первый ход делает Петя. <b>-1 или /2</b>. Игра завершится, когда <b>в двух кучах будет не более 20. В 1й куче 10, во второй s > 10</b>
		</p>
		<p>Найти S Ваня выйграет первым ходом при любой игре Пети</p>

		<p>20.MIN, MAX у Пети есть выйгрышная стратегия
		</p>
		<p>– Петя не может выиграть за один ход</p>
		<p>– Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня</p>

		<p>21. Найти S
		</p>
		<p>– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети</p>
		<p>– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом</p>

		<table>
			<tr>
				<td>a=b</td>
				<td>a==b</td>
			</tr>
			<tr>
				<td>в первой куче 13</td>
				<td>f(13, s , _)</td>
			</tr>
			<tr>
				<td>во второй от 1 до 23</td>
				<td>range(1,24)</td>
			</tr>
			<tr>
				<td>если a &#60; b</td>
				<td>if a &#60; b : h = [f(a+...,b,m-1),f()]</td>
			</tr>
			<tr>
				<td>else</td>
				<td>else: h = [f(a, b+..., m-1), f()]</td>
			</tr>
		</table>
		
		
		<pre>
def f(a, b, m):
 if a + b &#60;= 20: return m%2 == 0
 if m == 0: return 0
 h = [f(<b>a-1</b>, b, m-1), f(<b>(a+1)//2</b>,b,m-1), f(a, <b>b-1</b>,m-1), f(a, <b>(b+1)//2</b>, m-1)]
 return any(h) if m%2!=0 else all(h)
 
print([s for s in range<b>(11, 1000)</b> if f(10, s, 2)])
print([s for s in range(11, 1000) if not f(10, s, 1) and f(10,s,3)])
print([s for s in range(11, 1000) if not f(10, s, 2) and f(10,s,4)])

[21]
[22, 23, 31, 41, 42]
[24]</pre>



		<h2>(5 тип) 2 кучи камней, проверка ходов</h2>

		<p>19. Первый ход делает Петя. <b>+3 в меньшую кучу, в большей куче менять камни нельзя</b>. Игра завершится, когда кучи будут равны. В 1й куче 13 камней, во второй 1 &#60;= S &#60;= 23
		</p>
		<p>MIN S Петя выйграет за 1 ход, <b>но при любом ходе Пети Ваня может выйграть первым ходом</b></p>

		<p>20.
			2 MIN S
		</p>
		<p>– Петя не может выиграть за один ход</p>
		<p>– Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня</p>

		<p>21. Найти 2 S
		<p>– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети</p>
		<p>– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.</p>
		<p>- <b>Ваня может выйграть первым ходом после одного из ходов нети</b></p>



		<pre>
def f(a, b, m):
 if a == b: return m%2 == 0
 if m == 0: return 0
 if a &#60; b: h = [f(a+1, b, m-1), f(a+3, b, m-1)]
 else: h = [f(a, b+1, m-1),f(a, b+3, m-1)]
 return any(h) if m%2!=0 else all(h)
 
print([s for s in range(1, 24) if <b>not f(13,s,0)</b> and f(13, s, 2)])
print([s for s in range(1, 24) if not f(13,s,1) and f(13, s, 2)])
print([s for s in range(1, 24) if not f(13,s,2) and f(13, s, 4)])

[9, 11, 15, 17]
[9, 11, 13, 15, 17]
[5, 7, 19, 21]</pre>

		Проверим 3е условие для победы первым ходом
		<pre>
def f(a, b, m):
 if a == b: return m%2 == 0
 if m == 0: return 0
 if a &#60; b: h = [f(a+1, b, m-1), f(a+3, b, m-1)]
 else: h = [(f(a, b+1, m-1),f(a, b+3, m-1)]
 return any(h) if m%2!=0 else any(h)
 
print([s for s in range(1, 24) if not f(13,s,0) and f(13, s, 2)])
	
[7, 9, 11, 15, 17, 19]</pre>
		<p><b>! сравним два ответа
				[5, 7, 19, 21] и [7, 9, 11, 15, 17, 19], ответом на 21е задание будут числа 7 и 19, тк они оба есть в массивах</b></p>
	</div>
</body></html>
