<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ЕГЭ информатика</title>
	<link rel="icon" href="img/favicon.ico">
	<link rel="stylesheet" href="style.css">
</head>

<body>
	<div class="wrapper">
		<span>&#60; </span><a href="index.html">Вернуться к списку задач</a>
		<h1>Решение 19-20-21 задач</h1>
		

		<h2>(1 тип) 1 куча камней, победа</h2>

		<p>19. Первый ход делает Петя. <b>+3 или *5. Победа при >=301</b>
		</p>
		<p><b>MIN S</b> когда Ваня выигрывает первым при любом ходе Пети</p>

		<p>20. <b>Найти 2 минимальных</b></p>
			<p>– Петя не может выиграть за один ход</p>
			<p>– Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня</p>

		<p>21. <b>Минимальное значение S</b></p>
			<p>– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети</p>
			<p>– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом</p>
		<pre>
def f(a, m):
 if a >= 301: return m%2 == 0
 if m == 0: return 0
 h = [f(a+3, m-1), f(a*5, m-1)]
 return any(h) if (m-1)%2 == 0 else all(h)

print([s for s in range(1,301) if f(s,2)])
print([s for s in range(1, 301) if f(s, 3) > f(s,1)])
print([s for s in range(1,301) if f(s,4)>f(s,2)])

[58, 59, 60]
[12, 55, 56, 57]
[52, 53, 54]</pre>


		<h2>(2 тип) 1 куча камней, проигрыш</h2>

		<p>19. Первый ход делает Петя. <b>+2 или *3</b>. Игра завершится, когда будет <b>не менее 45, Если не более 112 то последний ход победный</b>
		</p>
		<p><b>MIN S</b> когда Ваня выигрывает первым при любом ходе Пети</p>

		<p>20. <b>Сколько значений?</b></p>
			<p>– Петя не может выиграть за один ход</p>
			<p>– Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня</p>

		<p>21.
			<b>Найти 2 значения</b>
		</p>
			<p>– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети</p>
			<p>– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом</p>
			
		<pre>
def f(a, m):
 if 45 &#60;= a &#60;= 112: return m%2 == 0
 if a > 112: return m%2!=0
 if m == 0: return 0
 h = [f(a+2, m-1), f(a*3, m-1)]
 return any(h) if (m-1)%2 == 0 else all(h)

print([s for s in range(1, 45) if f(s,2)])
print([s for s in range(1, 45) if not f(s, 1) and f(s, 3)])
print([s for s in range(1, 45) if  not f(s, 2) and f(s, 4)])

[41, 42]
[14, 39, 40]
[12, 13, 38]</pre>


		<h2>(3 тип) 2 кучи камней, неудачный первый ход Пети</h2>

		<p>19. Первый ход делает Петя. <b>+1 или *3</b>. Игра завершится, когда <b>в двух кучах будет не менее 45. В 1й куче 4 камня, во второй 1 &#60;= s &#60;= 40</b>
		</p>
		<p><b>найти min S</b> Ваня выйграл после <b>неудачного хода</b></p>

		<p>20.
			<b>Найти 2 значения</b>
		</p>
			<p>– Петя не может выиграть за один ход</p>
			<p>– Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня</p>

		<p>21.
			<b>Найти S</b>
		</p>
			<p>– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети</p>
			<p>– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом</p>

		<p><b>19. all меняем на any в коде, чтобы найти хотябы 1 победу</b></p>
		<pre>
def f(s, b, m):
 if a + b >= 45: return m%2 == 0
 if m == 0: return 0
 h = [f(a+1, b, m-1), f(a*3,b,m-1), f(a, b+1,m-1), f(a, b*3, m-1)]
 return any(h) if (m-1)%2 == 0 else any(h)
 
print([s for s in range(1, 41) if f(4, s, 2)])
		
[5]</pre>

		<p><b>20. 21. any меняем на all</b></p>
		<pre>
def f(a, b, m):
 if a + b >= 45: return m%2 == 0
 if m == 0: return 0
 h = [f(a+1, b, m-1), f(a*3,b,m-1), f(a, b+1,m-1), f(a, b*3, m-1)]
 return any(h) if (m-1)%2 == 0 else all(h)
 
print([s for s in range(1, 41) if not f(4, s, 1) and f(4,s,3)])
print([s for s in range(1, 41) if not f(4, s, 2) and f(4,s,4)])

[8, 13]
[12]</pre>



		<h2>(4 тип) 2 кучи камней, с уменьшением</h2>

		<p>19. Первый ход делает Петя. <b>-1 или /2</b>. Игра завершится, когда <b>в двух кучах будет не более 20. В 1й куче 10, во второй s > 10</b>
		</p>
		<p><b>Найти S</b> Ваня выйграет первым ходом при любой игре Пети</p>

		<p>20.
			<b>MIN S и MAX</b> у Пети есть выйгрышная стратегия</p>
			<p>– Петя не может выиграть за один ход</p>
			<p>– Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня</p>

		<p>21.
			<b>Найти S</b></p>
			<p>– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети</p>
			<p>– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом</p>

		<pre>
[21]
[22, 23, 31, 41, 42]
[24]
def f(a, b, m):
 if a + b &#60;= 20: return m%2 == 0
 if m == 0: return 0
 h = [f(a-1, b, m-1), f((a+1)//2,b,m-1), f(a, b-1,m-1), f(a, (b+1)//2, m-1)]
 return any(h) if (m-1)%2 == 0 else all(h)
 
print([s for s in range(11, 1000) if f(10, s, 2)])
print([s for s in range(11, 1000) if not f(10, s, 1) and f(10,s,3)])
print([s for s in range(11, 1000) if not f(10, s, 2) and f(10,s,4)])</pre>



		<h2>(5 тип) 2 кучи камней, проверка ходов</h2>

		<p>19. Первый ход делает Петя. <b>+3 в меньшую кучу, в большей куче менять камни нельзя</b>. Игра завершится, когда кучи будут равны. В 1й куче 13 камней, во второй 1 &#60;= S &#60;= 23
		</p>
		<p><b>MIN S</b> Петя выйграет за 1 ход, <b>но при любом ходе Пети Ваня может выйграть первым ходом</b></p>

		<p>20.
			<b>2 MIN S</b></p>
			<p>– Петя не может выиграть за один ход</p>
			<p>– Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня</p>
			
		<p>21.
			<b>Найти 2 S</b>
			<p>– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети</p>
			<p>– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.</p>
			<p>- <b>Ваня может выйграть первым ходом после одного из ходов нети</b></p>
				
		

		<pre>
[9, 11, 15, 17]
[9, 11, 13, 15, 17]
[5, 7, 19, 21]
def f(a, b, m):
 if a == b: return m%2 == 0
 if m == 0: return 0
 if a &#60; b: h = [f(a+1, b, m-1), f(a+3, b, m-1)]
 else: h = [f(a, b+1, m-1),f(a, b+3, m-1)]
 return any(h) if (m-1)%2 == 0 else all(h)
 
print([s for s in range(1, 24) if not f(13,s,0) and f(13, s, 2)])
print([s for s in range(1, 24) if not f(13,s,1) and f(13, s, 2)])
print([s for s in range(1, 24) if not f(13,s,2) and f(13, s, 4)])</pre>

		Проверим 3е условие для победы первым ходом
		<pre>
[7, 9, 11, 15, 17, 19]
def f(a, b, m):
 if a == b: return m%2 == 0
 if m == 0: return 0
 if a &#60; b: h = [f(a+1, b, m-1), f(a+3, b, m-1)]
 else: h = [(f(a, b+1, m-1),f(a, b+3, m-1)]
 return any(h) if (m-1)%2 == 0 else any(h)
 
print([s for s in range(1, 24) if not f(13,s,0) and f(13, s, 2)])</pre>
		<p><b>! сравним два ответа
				[5, 7, 19, 21] и [7, 9, 11, 15, 17, 19], ответом на 21е задание будут числа 7 и 19, тк они оба есть в массивах</b></p>
	</div>
</body></html>
