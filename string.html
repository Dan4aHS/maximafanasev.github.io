<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
	<link rel="stylesheet" href="main.css">
</head>

<body>

	<h2>Строки</h2>

	<h3>Общее</h3>

	<ol>
		<li>Типы кавычек</li>
		<li>Неизменяемость строк</li>
		<li>Спецсимволы \</li>
		<li>Доступ к символам</li>
		<li>Сравнение строк</li>
	</ol>
	
	<h3>Методы строк</h3>
	
	<ol>
		<li>Длина строки</li>
		<li>str.toLowerCase() и str.toUpperCase()</li>
		<li>str.slice</li>
		<li>startsWith, endsWith</li>
		<li>~2</li>
		<li>str.codePointAt(pos)</li>
		<li>str.fromCodePoint(code)</li>
		<li>str.concat</li>
		<li>str.includes</li>
		<li>str.indexOf</li>
		<li>str.search</li>
		<li>str.replace</li>
		<li>str.padEnd str.padStart</li>
		<li>str.trim</li>
		<li>str.charCodeAt</li>
	</ol>

	<h3>Общее</h3>
	<ol>
		<li>кавычки</li>
		<pre>
let single = 'single-quoted';
let double = "double-quoted";
let backticks = `backticks`;

function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
</pre>

		<li>Неизменяемость строк</li>
		<pre>
let str = 'Hi';

str[0] = 'h'; // ошибка
alert( str[0] ); // не работает
</pre>

		<li>Спецсимволы \</li>
		<pre>
\n	Перевод строки
\r	В текстовых файлах Windows для перевода строки используется комбинация символов \r\n, а на других ОС это просто \n. Это так по историческим причинам, ПО под Windows обычно понимает и просто \n.
\', \"	Кавычки
alert( 'I\'m the Walrus!' ); // I'm the Walrus!
\\	Обратный слеш
\t	Знак табуляции
\b, \f, \v
</pre>

		<li>Доступ к символам</li>
		<pre>
let str = `Hello`;

// получаем первый символ
alert( str[0] ); // H
alert( str.at(0) ); // H

alert( str[-2] ); // undefined
alert( str.at(-2) ); // l

// получаем последний символ
alert( str[str.length - 1] ); // o
alert( str.at(-1) );
</pre>

		<li>Сравнение строк</li>
		<pre>
alert( 'a' > 'Z' ); // true
alert( 'Österreich'.localeCompare('Zealand') ); // -1
</pre>

	</ol>

	<h3>Методы строк</h3>

	<ol>
		<li>Длина строки</li>
		<pre>
alert( `My\n`.length ); // 3
</pre>

		<li>toLowerCase() и toUpperCase()</li>
		<pre>
alert( 'Interface'[0].toLowerCase() ); // 'i'
</pre>

		<li>Получение подстроки</li>
		<pre>
let str = "stringify";
// 'strin', символы от 0 до 5 (не включая 5)
alert( str.slice(0, 5) );
// 's', от 0 до 1, не включая 1, т. е. только один символ на позиции 0
alert( str.slice(0, 1) );

let str = "stringify";
alert( str.slice(2) ); // ringify, с позиции 2 и до конца

let str = "stringify";

// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
alert( str.slice(-4, -1) ); // gif
</pre>

		<li>startsWith, endsWith</li>
		<pre>
alert( "Widget".startsWith("Wid") ); // true, "Wid" — начало "Widget"
alert( "Widget".endsWith("get") ); // true, "get" — окончание "Widget"
</pre>

		<li>побитовым НЕ</li>
		<pre>
alert( ~2 ); // -3, то же, что -(2+1)
alert( ~1 ); // -2, то же, что -(1+1)
alert( ~0 ); // -1, то же, что -(0+1)
alert( ~-1 ); // 0, то же, что -(-1+1)
</pre>

		<li>str.codePointAt(pos)</li>
		<pre>
alert( "z".codePointAt(0) ); // 122
</pre>

		<li>String.fromCodePoint(code)</li>
		<pre>
Создаёт символ по его коду code
</pre>

		<li>Объединяет две или более строки и возвращает одну строку.</li>
		<pre>
"Hello".concat(" Tproger"); // "Hello Tproger"
"Hello".concat(" T", "p", "r", "o", "g", "e", "r"); // "Hello Tproger"
</pre>

		<li>Разбивает строку в массив по указанному разделителю, которым может быть подстрока или регулярное выражение. Вторым параметром можно указать ограничитель.</li>
		<pre>
// Получаем каждый символ
"Hello Tproger".split(""); // ["H", "e", "l", "l", "o", " ", "T", "p", "r", "o", "g", "e", "r"]

// Получаем каждое слово из строки
"Hello Tproger".split(" "); //["Hello", "Tproger"]

// Устанавливаем ограничитель
"Hello Tproger".split(" ", 1); //["Hello"]
</pre>

		<li>Принимает в качестве параметра число и повторяет строку указанное количество раз.</li>
		<pre>
"Tproger ".repeat(3); // "Tproger Tproger Tproger "
</pre>

		<li>charAt</li>
		<pre>
"Hello Tproger".charAt(); // "H"
</pre>

		<li>Проверяет, содержит ли строка указанную подстроку. Возвращает значение true или false. Вторым параметром можно указать позицию в строке, с которой следует начать поиск.</li>
		<pre>
"Hello Tproger".includes("Tproger"); // true
"Hello Tproger".includes("Hello", 1); // falseПроверяет, содержит ли строка указанную подстроку. Возвращает значение true или false
</pre>

		<li>Возвращает индекс первого найденного вхождения указанного значения. Поиск ведётся от начала до конца строки. Если совпадений нет, возвращает -1. Вторым параметром можно передать позицию, с которой следует начать поиск.</li>
		<pre>
"Hello World".indexOf("o"); // 4
"Hello World".indexOf("o", 5); // 7
</pre>

		<li>Проверяет, есть ли в строке указанное значение или регулярное выражение и возвращает индекс начала совпадения.</li>
		<pre>
"hi, hello, hey".search("hello"); // 4
</pre>

		<li>Ищет в строке указанное значение или регулярное выражение и возвращает новую строку, в которой выполнена замена на второй параметр. Можно заменить найденные значения другой строкой или передать функцию для работы над совпадениями.</li>
		<pre>
"hi, hello, hi".replace("hi", "hey"); // "hey, hello, hi"
"hi, hello, hi".replace(/hi/g, "hey"); // "hey, hello, hey"
</pre>

		<li>Добавляет в конце отступы, пока строка не достигнет длины, заданной первым параметром. Вторым параметром можно указать другой символ вместо пробела.</li>
		<pre>
"Hello Tproger".padEnd(20, "*"); // "Hello Tproger*******"
</pre>

		<li>Обрезает пробелы с обоих концов строки.</li>
		<pre>
"   Hello Tproger ".trim(); // "Hello Tproger"
</pre>

		<li>Возвращает числовое значение Юникода по указанному индексу. Обратите внимание: у букв в верхнем и нижнем регистрах разные коды.</li>
		<pre>
"T".charCodeAt() // 84
"t".charCodeAt() // 116
</pre>

	</ol>

</body></html>