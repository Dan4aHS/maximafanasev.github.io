<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Title</title>
	<link rel="stylesheet" href="main.css">
</head>

<body>

	<h2>Web Technologies</h2>
	<table>
		<tr>
			<td>Серверный рендеринг</td>
			<td>генерирует HTML на сервере и отдаёт пользователю готовый исходный код со всем DOM
		</tr>
		<tr>
			<td>Клиентский</td>
			<td>клиенту отдает JS-бандл</td>
		</tr>
		<tr>
			<td>Прогрессивный</td>
			<td>можно один раз создать себе сайт и выложить его на сервер, где есть только Nginx</td>
		</tr>
		<tr>
			<td>PWA</td>
			<td>мобильное приложение в браузере</td>
		</tr>
		<tr>
			<td>Сетевая модель OSI</td>
			<td>Посредством данной модели различные сетевые устройства могут взаимодействовать друг с другом</td>
		</tr>
		<tr>
			<td>REST</td>
			<td>способ создания API с помощью протокола HTTP</td>
		</tr>
		<tr>
			<td>RESTful API</td>
			<td>интерфейс,используемые двумя компьютерными системами для безопасного обмена информацией через Интернет</td>
		</tr>
		<tr>
			<td>History API</td>
			<td>доступ к управлению историей браузера в рамках текущей сессии</td>
		</tr>
		<tr>
			<td>Local Storage</td>
			<td>Хранит данные бессрочно.
				Очищается только с помощью JavaScript или очистки кэша браузера.
				Хранит данные объёмом до 5 МБ, это самый большой объём из трёх вариантов хранилища.
				Не поддерживается старыми браузерами, например, IE 7 и ниже.
				Работает по правилу ограничения домена (same origin policy). То есть сохранённые данные доступны только для одного источника</td>
		</tr>
		<tr>
			<td>Session Storage</td>
			<td>Хранит данные, пока продолжается текущая сессия. Когда пользователь закрывает браузер, данные становятся недоступными.
				Используется контекст браузера верхнего уровня, поэтому каждая вкладка браузера хранит уникальные данные.
				Объём данных больше чем в Cookie.
				Не поддерживается старыми браузерами, например, IE 7 и ниже.</td>
		</tr>
		<tr>
			<td>Cookie</td>
			<td>Хранит данные, которые можно передавать на сервер через заголовки.
				Локальное и сессионное хранилище доступны только на клиентской стороне.
				Срок хранения устанавливается при создании cookie.
				Объём данных не превышает 4 Кбайт.
				Cookie могут быть защищёнными, в этом случае их содержимое нельзя получить на стороне клиента. Это важно для аутентификации при хранении пользовательских токенов.</td>
		</tr>
		<tr>
			<td>Core Web Vitals</td>
			<td>группа новых факторов ранжирования Google, которые запускаются в мае 2021 года. В эту группу входят 3 параметра: LCP (Largest Contentful Paint) — скорость загрузки основного контента. Основной контент — это самый большой элемент на странице: текст, видео</td>
		</tr>
		<tr>
			<td>метрика Core Web Vitals</td>
			<td>LCP (Largest Contentful Paint) — скорость загрузки основного контента веб-страницы. Основной контент — это самый большой элемент на странице: текст, видео, картинка. Гугл сравнивает разницу между загрузкой основного контента и остальных элементов веб-страницы.

				FID (First Input Delay) — время ожидания до начала взаимодействия пользователя с сайтом. Чем дольше пользователю приходится ждать момента, когда можно начать взаимодействовать со страницей (скролить, кликать по ссылкам, наживать на кнопки) тем ниже лидогенерация и выше показатель отказов.

				CLS (Cumulative Layout Shift) — устойчивость верстки и элементов, которые мешают пользователю взаимодействовать с сайтом. Если в процессе загрузки элементы, особенно кликабельные, смещаются по экрану, пользователь может нажать не на ту кнопку, что не понравится ни пользователю, ни Google.</td>
		</tr>
		<tr>
			<td>PRPL</td>
			<td>это паттерн, рекомендуемый командой разработчиков Chrome для организации поэтапной загрузки кода. Он рассчитан на то, чтобы приложения, использующие его, как можно быстрее становились бы интерактивными на дешёвых устройствах и в медленных сетях. Паттерн PRPL поощряет предварительную загрузку минимального объёма JS-кода, необходимого для того, чтобы со страницей можно было бы работать. Затем ресурсы загружаются с использованием методик ленивой загрузки. Если нужно — можно воспользоваться сервис-воркером для предварительного кэширования JavaScript-ресурсов, необходимых для будущих взаимодействий с сайтом.</td>
		</tr>
	</table>

	<h2 class="accordion">Web API</h2>
	<table>
		<tr>
			<td>HTTP-запрос</td>
			<td>для передачи гипертекстовых документов, то есть документов, которые могут содержать ссылки, позволяющие организовать переход к другим документам</td>
		</tr>
		<tr>
			<td>Какие методы может иметь HTTP-запрос?</td>
			<td>OPTIONS.
				GET.
				HEAD.
				POST.
				PUT.
				PATCH.
				DELETE.
				TRACE.</td>
		</tr>
		<tr>
			<td>HTTP/2</td>
			<td>двоичный уровень кадрирования</td>
		</tr>
		<tr>
			<td>мультиплексирование в HTTP/2</td>
			<td>множество запросов в рамках одного TCP-соединения</td>
		</tr>
		<tr>
			<td>трехстороннее рукопожатие Triple handshake</td>
			<td>соединения между локальным хостом/клиентом и сервером</td>
		</tr>
		<tr>
			<td>PUT запрос</td>
			<td>должен быть задан уникальный ID указанного ресурса</td>
		</tr>
		<tr>
			<td>TCP и UDP</td>
			<td>TCP предполагает потоковую передачу данных, границы фрагментов данных не обозначены. UDP использует метод датаграмм, когда получатель проверяет целостность пакетов лишь при получении сообщения</td>
		</tr>
		<tr>
			<td>WebSocket</td>
			<td>двунаправленный протокол связи между клиентом (браузером) и сервером, позволяющий обмениваться сообщениями в режиме реального времени.</td>
		</tr>
		<tr>
			<td>Long Polling</td>
			<td>процесс, при котором соединение между сервером и клиентом не разрывается длительный период, а при разрыве повторно создается.</td>
		</tr>
		<tr>
			<td>Server Sent Events</td>
			<td>Идеально подойдет для динамически изменяемой информации в приложении. Например, различная real-time статистика, текстовые трансляции матчей и так далее</td>
		</tr>
		<tr>
			<td>JSONP</td>
			<td>JSONP работает путем внедрения тега script на страницу, который загружает файл JSON с сервера и обрабатывает его с помощью пользовательской функции.</td>
		</tr>
		<tr>
			<td>IndexedDB</td>
			<td>IndexedDB — это механизм, который позволяет хранить большие объемы данных на клиентской стороне, где браузер обладает доступом к файловой системе пользователя</td>
		</tr>
		<tr>
			<td>Service Workers</td>
			<td>скрипт, который работает в фоновом режиме, независимо от веб-страницы</td>
		</tr>
		<tr>
			<td>Web Workers</td>
			<td>ресурсоёмкие вычисления могут выполняться в отдельном потоке</td>
		</tr>
		<tr>
			<td>SSL/TLS</td>
			<td>цифровой объект, который позволяет системам проверять личность и впоследствии устанавливать зашифрованное сетевое соединение с другой системой</td>
		</tr>
		<tr>
			<td>CDN</td>
			<td>это географически распределённая сетевая инфраструктура</td>
		</tr>
		<tr>
			<td>IP-адрес</td>
			<td>это уникальный адрес, идентифицирующий устройство в интернете или локальной сети</td>
		</tr>
		<tr>
			<td>Доменные имена, Хостинг</td>
			<td>который вводят пользователи, чтобы зайти на сайт, место размещения веб-сайтов на серверах.</td>
		</tr>
		<tr>
			<td>URL</td>
			<td>Uniform Resource Locator (унифицированный определитель местонахождения ресурса)</td>
		</tr>
		<tr>
			<td>URN</td>
			<td>Unifrorm Resource Name (унифицированное имя ресурса)</td>
		</tr>
		<tr>
			<td>Идентификация</td>
			<td>процедура, в результате выполнения которой для субъекта идентификации выявляется его идентификатор, однозначно определяющий этого субъекта в информационной системе.</td>
		</tr>
		<tr>
			<td>Аутентификация</td>
			<td>процедура проверки подлинности, например проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных.</td>
		</tr>
		<tr>
			<td>Авторизация</td>
			<td>предоставление определенному лицу или группе лиц прав на выполнение определенных действий.</td>
		</tr>
		<tr>
			<td>Виды аутентификации</td>
			<td>электронной подписи,по паролям,SMS,Биометрическая аутентификация,географическое местоположение,Многофакторная аутентификация</td>
		</tr>
		<tr>
			<td>(Secure) и HttpOnly cookies</td>
			<td>Атрибут secure и флаг httpOnly работают вместе, чтобы гарантировать, что браузер может ограничить доступ к защищенным данным cookie из вредоносных скриптов, которые могли заразить браузер или сеть.</td>
		</tr>
		<tr>
			<td>Content Security Policy</td>
			<td>дополнительный уровень безопасности, позволяющий распознавать и устранять определённые типы атак, таких как Cross Site Scripting</td>
		</tr>
		<tr>
			<td>Cross-Origin Resource Sharing</td>
			<td>использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент.</td>
		</tr>
		<tr>
			<td>XSS</td>
			<td>тип атаки на веб-системы, заключающийся во внедрении в выдаваемую веб-системой страницу вредоносного кода</td>
		</tr>
		<tr>
			<td>Методы повышения безопасности веб-приложений</td>
			<td>проверка данных на соответствие стандартам протоколов;
				контроль трафика на основе нейронных сетей;
				сигнатурный анализ;
				защита от SQL-инъекций;
				протекция от межсетевого скриптинга (XSS);
				контроль доступа к конфиденциальным данным.</td>
		</tr>
		<tr>
			<td>OWASP</td>
			<td>это стандартный информационный документ для разработчиков и безопасности веб-приложений</td>
		</tr>
		<tr>
			<td>композиция и наследование</td>
			<td>композиция даёт возможность переиспользовать код без расширения существующего класса, как это происходит в случае с наследованием</td>
		</tr>
		<tr>
			<td>Шаблон проектирования</td>
			<td>(паттерн, от англ. design pattern) — повторяемая архитектурная конструкция в сфере проектирования программного обеспечения, предлагающая решение проблемы проектирования в рамках некоторого часто возникающего контекста.</td>
		</tr>
		<tr>
			<td>Полиморфизм</td>
			<td>способность функции работать с данными разных типов</td>
		</tr>
		<tr>
			<td>Абстрактные классы в объектно-ориентированном программировании</td>
			<td>базовые классы, которые можно наследовать, но нельзя реализовывать. То есть на их основе нельзя создать объект</td>
		</tr>
		<tr>
			<td>JavaScript каждый объект имеет объект-прототип</td>
			<td>В свою очередь этот объект-прототип может содержать в себе другой прототип и наследовать свойства уже от него. В итоге объект-экземпляр получает доступ ко всей цепочке прототипов и их свойствам и методам.</td>
		</tr>
		<tr>
			<td>Реактивное программирование</td>
			<td>парадигма программирования, ориентированная на потоки данных и распространение изменений. Это означает, что должна существовать возможность легко выражать статические и динамические потоки данных, а также то, что нижележащая модель исполнения должна автоматически распространять изменения благодаря потоку данных.</td>
		</tr>
		<tr>
			<td>Inversion of Control</td>
			<td>каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других компонентов.</td>
		</tr>
	</table>

	<h2>OOP & FP (вопросы из объектно-ориентированного и функционального программирования)</h2>
	<table>
		<tr>
			<td>ООП</td>
			<td>
				<ul>
					<li>Инкапсулируйте все, что может изменяться;</li>
					<li>Уделяйте больше внимания интерфейсам, а не их реализациям;</li>
					<li>Каждый класс в вашем приложении должен иметь только одно назначение;</li>
					<li>Классы — это их поведение и функциональность.</li>
				</ul>
			</td>
		</tr>
		<tr>
			<td>Абстракция</td>
			<td>отделение концепции от ее экземпляра</td>
		</tr>
		<tr>
			<td>Полиморфизм</td>
			<td>реализация задач одной и той же идеи разными способами</td>
		</tr>
		<tr>
			<td>Наследование</td>
			<td>способность объекта или класса базироваться на другом объекте или классе</td>
		</tr>
		<tr>
			<td>Инкапсуляция</td>
			<td>размещение одного объекта или класса внутри другого для разграничения доступа к ним</td>
		</tr>
		<tr>
			<td>Делегация</td>
			<td>перепоручение задачи от внешнего объекта внутреннему</td>
		</tr>
		<tr>
			<td>Композиция</td>
			<td>включение объектом-контейнером объекта-содержимого и управление его поведением; последний не может существовать вне первого
			</td>
		</tr>
		<tr>
			<td>Агрегация</td>
			<td>включение объектом-контейнером ссылки на объект-содержимое; при уничтожении первого последний продолжает существование
			</td>
		</tr>
		<tr>
			<td>DRY</td>
			<td>Не повторяйся</td>
		</tr>
		<tr>
			<td>Принцип единственной обязанности</td>
			<td>Для каждого класса должно быть определено единственное назначение</td>
		</tr>
		<tr>
			<td>Принцип открытости/закрытости</td>
			<td>Программные сущности должны быть открыты для расширения, но закрыты для изменений</td>
		</tr>
		<tr>
			<td>Принцип подстановки Барбары Лисков</td>
			<td>Методы, использующие некий тип, должны иметь возможность использовать его подтипы, не зная об этом</td>
		</tr>
		<tr>
			<td>Принцип разделения интерфейсов</td>
			<td> Предпочтительнее разделять интерфейсы на более мелкие тематические, чтобы реализующие их классы не были вынуждены определять методы, которые непосредственно в них не используются</td>
		</tr>
		<tr>
			<td>Принцип инверсии зависимостей</td>
			<td>Система должна конструироваться на основе абстракций «сверху вниз»: не абстракции должны формироваться на основе деталей, а детали должны формироваться на основе абстракций</td>
		</tr>
		<tr>
			<td>SOLID</td>
			<td>принципы объектно‑ориентированного программирования</td>
		</tr>
		<tr>
			<td>Классовое наследование</td>
			<td>экземпляры наследуются от классов, создаются подклассовые отношения</td>
		</tr>
		<tr>
			<td>лучше использовать прототипное наследование</td>
			<td>Делегирование (цепочка прототипов)
				Конкатенация (миксины, Object.assign())
				Функциональное наследование (не путать с функциональным программированием. Функция используется для создания замыкания для private/инкапсуляции)</td>
		</tr>
		<tr>
			<td>Двусторонняя связь данных</td>
			<td>поля интерфейса связаны с моделью данных динамически, то есть при изменении полей интерфейса меняется модель, и наоборот</td>
		</tr>
		<tr>
			<td>Функциональное программирование</td>
			<td>подразумевает вычисление математических функций, избегая общих состояний и изменяемых данных</td>
		</tr>
		<tr>
			<td>MVC</td>
			<td>способ организации кода, который предполагает выделение блоков, отвечающих за решение разных задач</td>
		</tr>
		<tr>
			<td>MVVM</td>
			<td>паттерн разработки, позволяющий разделить приложение на три функциональные части:

				Model — основная логика программы (работа с данными, вычисления, запросы и так далее)
				View — вид или представление (пользовательский интерфейс)
				ViewModel — модель представления, которая служит прослойкой между View и Mode</td>
		</tr>
		<tr>
			<td>Minimal Viable Product</td>
			<td>тестовая версия товара, услуги или сервиса с минимальным набором функций (иногда даже одной), которая несет ценность для конечного потребителя</td>
		</tr>
		<tr>
			<td>Метод</td>
			<td>функция или процедура, которая принадлежит классу или экземпляру класса</td>
		</tr>
		<tr>
			<td>Каррирование</td>
			<td>f(a, b, c), а как f(a)(b)(c)</td>
		</tr>
		<tr>
			<td>Монолитная архитектура</td>
			<td>отдельная большая вычислительная сеть с единой базой кода, в которой объединены все бизнес-задачи</td>
		</tr>
		<tr>
			<td>Микросервисная архитектура</td>
			<td>метод организации архитектуры, основанный на ряде независимо развертываемых служб</td>
		</tr>
		<tr>
			<td>дескрипторы</td>
			<td>пары ключ-значение, которые описывают поведение свойства объекта при выполнении операций над ним (например, чтения или записи)</td>
		</tr>
		<tr>
			<td>Геттеры и сеттеры</td>
			<td>аксессоры или вычисляемые свойства. Это методы, имитирующие поля, но позволяющие читать и записывать данные. Геттеры используются для получения данных, сеттеры — для их изменения</td>
		</tr>
	</table>
	
	
	</body>
</html>
