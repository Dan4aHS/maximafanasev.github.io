<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Title</title>
	<link rel="stylesheet" href="main.css">
</head>

<body>

	<h2>HTML</h2>
	<div class="main">
		<pre>
HTML

class
data-*
dir (en-US)
hidden (en-US)
id
lang
style
tabindex
title (en-US)
translate (en-US)
</pre>
		<pre>
Метатеги
viewport
picture
srcset
decoding
enterkeyhint
pattern
</pre>
	</div>
	<h2>CSS</h2>
	<div class="main">
		<pre>
STATIC. RELATIVE. ABSOLUTE. FIXED. STICY
initial
inherit
currentColor
</pre>
		<pre>
grayscale(% | число)
sepia(% | число)
blur(px)
brightness (% | число)
contrast(% | число)
saturate(% | число)
hue-rotate(deg)
invert(% | число)
</pre>
		<pre>
text-rendering</pre>
	</div>

	<h2>Основы</h2>
	<div class="main">
		<pre>
script src="script.js"
script src="script2.js"
script src="script.js?v=1"
</pre>
		<pre>
"use strict";
/*
комментарий
*/
</pre>
		<pre>
str, my_str, myStr, a1, $, $a, $$a
</pre>
		<pre>
let a;    // объявим переменную
a = 3;    // присвоим ей значение
alert(a); // выведем значение переменной на экран
</pre>
		<pre>
undefined, null, true, false, NaN, Infinity, -Infinity
</pre>
	</div>

	<h2>Числа</h2>
	<div class="main">
		<pre>
IEEE-754
(2**53-1) Bigint
1e9
a = 0b11111111 let b = 0o377</pre>
		<pre>
alert(10 % 3); // выведет 1
</pre>
		<pre>
alert(10 ** 3); // выведет 1000
</pre>
		<pre>
let num = 1;   // объявляем переменную num и записываем в нее значение 1
num = num + 2; // записываем в num ее саму плюс 2
alert(num);    // выведет 3
</pre>
		<pre>
let num = 0;
num++;        // прибавляем к переменной a число 1
alert(num);   // выведет 1
</pre>
		<pre>
let num = 0;
alert(++num); // выведет 1 - переменная увеличилась сразу
</pre>
		<pre>
Math.pow Math.sqrt
</pre>
		<pre>
Math.round Math.ceil Math.floor toFixed toPrecision
</pre>
		<pre>
Math.max Math.min
</pre>
		<pre>
Math.random
</pre>
		<pre>
Math.abs
</pre>
		<pre>
const pi = 3.14;
</pre>
		<pre>
alert('2' * '3'); // выведет 6
</pre>
		<pre>
let a = '2';
let b = '3';
alert(Number(a) + Number(b)); // выведет 5
</pre>
		<pre>
let a = '2';
let b = +a; // в b запишется число 2
</pre>
		<pre>
alert(Number('2s')); // выведет NaN
</pre>
		<pre>
let num = parseInt('12px');
alert(num); // выведет 12
</pre>
		<pre>
let num = parseFloat('12.5px');
alert(num); // выведет 12.5
</pre>
		<pre>
let test = 12345;
alert(test[0]); // выдаст undefined
</pre>
		<pre>
let test = String(12345); // строка
alert(Number(test[0]) + Number(test[1])); // выведет 3
</pre>
	</div>

	<h2>Строки</h2>
	<div class="main">
		<pre>
let str = 'abc';
let str = 'abc' + 'def'; // складываем две строки
alert(str); // выведет 'abcdef'
</pre>
		<pre>
alert(str.length); // выведет 6
</pre>
		<pre>
let str = 'xxx';
let txt = `aaa ${str} bbb`;
</pre>
		<pre>
let str = `abc
def`; // так будет работать
</pre>
		<pre>
let a = '2';
let b = '3';
alert(a + b); // выведет '23'
</pre>
		<pre>
let str = String(123); // теперь в переменной строка '123'
</pre>
		<pre>
let str = 'abcde';
alert(str[0]); // выведет 'a'
</pre>
		<pre>
console.log(Boolean(0));  // false
</pre>
		<pre>
let str = 'abcde';
str[0] = '!';
</pre>
		<pre>
let test = '12345';
alert(test[0] + test[1]); // выведет '12' - суммирует как строки
</pre>
		<pre>
...'abcde' // 'a','b','c','d','e'
str.toLowerCase() и str.toUpperCase()
str.slice
startsWith, endsWith
~2
str.codePointAt(pos)
str.concat
str.includes
str.indexOf
str.search
str.replace
str.padEnd str.padStart
str.trim
str.charCodeAt</pre>
	</div>

	<h2>Условия</h2>
	<div class="main">
		<pre>
let test = 1;

if (test > 0) {
	console.log('+++'); // сработает это
} else {
	console.log('---');
}
</pre>
		<pre>
if (3 !== 3) {
	console.log('+++');
} else {
	console.log('---'); // сработает это
}
</pre>
		<pre>
if ('3' !== 3) {
	console.log('+++'); // сработает это
} else {
	console.log('---');
}

</pre>
		<pre>
let num = 3;

if (num > 0 && num < 10) {
	console.log('+++');
} else {
	console.log('---');
}

if (num1 > 0 || num2 > 0) {
	console.log('+++'); // сработает это
} else {
	console.log('---');
}
</pre>
		<pre>
switch (переменная) {
	case 'значение1':
		/*
			здесь код, который выполнится в случае,
			если переменная имеет значение1
		*/
	break;
	case 'значение2':
		/*
			здесь код, который выполнится в случае,
			если переменная имеет значение2
		*/
	break;
	case 'значение3':
		/*
			здесь код, который выполнится в случае,
			если переменная имеет значение3
		*/
	break;
	default:
		/*
			здесь код, который выполнится в случае,
			если не совпала ни с одним значением
		*/
	break;
}
</pre>
		<pre>
let num = 1; // пусть здесь число 1

switch (num) {
	case 1:
		console.log(1); // сработает это
	case 2:
		console.log(2); // сработает и это
	case 3:
		console.log(3); // сработает и это
}
</pre>
		<pre>
let age = 17;
let adult;
if (age >= 18) {
	adult = true;
} else {
	adult = false;
}
console.log(adult);
</pre>
		<pre>
if (true) {
	let res = '!';
}
console.log(res);
</pre>
		<pre>
let res = 1;
if (true) {
	let res = 2; // объявим переменную через let
}
console.log(res); // выведет 1, а не 2!
</pre>
		<pre>
let res = 1;
if (true) {
	let res = 2;
	console.log(res); // выведет 2
}
console.log(res); // выведет 1</pre>
	</div>

	<h2>Массивы</h2>
	<div class="main">
		<pre>
let arr = ['a', 'b', 'c'];
console.log(arr[0]); // выведет 'a'
console.log(arr.length) // выведет 3
arr[0] = '!';
console.log(arr); // выведет ['!', 'b', 'c']
arr[0] = arr[0] + '!';
arr[1] = arr[1] + '!';
arr[2] = arr[2] + '!';
console.log(arr); // выведет ['a!', 'b!', 'c!']
</pre>
		<pre>
let arr = [1, 2, 3, 4];
arr[0]++;
++arr[1];
arr[2]--;
--arr[3];
console.log(arr); // выведет [2, 3, 2, 3]
</pre>
		<pre>
let arr = [];
arr[0] = 'a';
arr[1] = 'b';
arr[2] = 'c';
console.log(arr); // выведет ['a', 'b', 'c']
</pre>
		<pre>
let arr = ['a', 'b', 'c'];
arr[4] = '!';
console.log(arr); // выведет ['a', 'b', 'c', undefined, '!']
</pre>
		<pre>
let arr = ['a', 'b', 'c'];
let key = 0; // запишем ключ в переменную
console.log(arr[key]); // выведет 'a'</pre>
	</div>

	<h2>Массивы методы</h2>
	<div class="main">
		<pre>
const myAwesomeArray = ["a", "b", "c", "d", "e"]
myAwesomeArray.some(test => test === "d")
//-------> Output : true
</pre>
		<pre>
const myAwesomeArray = [1, 2, 3, 4, 5]
myAwesomeArray.reduce((total, value) => total * value)
// 1 * 2 * 3 * 4 * 5
//-------> Output = 120
</pre>
		<pre>
const myAwesomeArray = ["a", "b", "c", "d", "e"]
myAwesomeArray.every(test => test === "d")
//-------> Output : false
const myAwesomeArray2 = ["a", "a", "a", "a", "a"]
myAwesomeArray2.every(test => test === "a")
//-------> Output : true
</pre>
		<pre>
const myAwesomeArray = [5, 4, 3, 2, 1]
myAwesomeArray.map(x => x * x)
//-------> Output : 25
//                  16
//                  9
//                  4
//                  1
</pre>
		<pre>
const myAwesomeArray = [[1, 2], [3, 4], 5]
myAwesomeArray.flat()
//-------> Output : [1, 2, 3, 4, 5]
</pre>
		<pre>
const myAwesomeArray = [
  { id: 1, name: "john" },
  { id: 2, name: "Ali" },
  { id: 3, name: "Mass" },
  { id: 4, name: "Mass" },
]
myAwesomeArray.filter(element => element.name === "Mass")
//-------> Output : 0:{id: 3, name: "Mass"},
//                  1:{id: 4, name: "Mass"}
</pre>
		<pre>
const myAwesomeArray = [
  { id: 1, name: "john" },
  { id: 2, name: "Ali" },
  { id: 3, name: "Mass" },
]
myAwesomeArray.forEach(element => console.log(element.name))
//-------> Output : john
//                  Ali
//                  Mass
</pre>
		<pre>
const myAwesomeArray = [
  { id: 1, name: "john" },
  { id: 2, name: "Ali" },
  { id: 3, name: "Mass" },
]
myAwesomeArray.findIndex(element => element.id === 3)
//-------> Output : 2
myAwesomeArray.findIndex(element => element.id === 7)
//-------> Output : -1
</pre>
		<pre>
const myAwesomeArray = [
  { id: 1, name: "john" },
  { id: 2, name: "Ali" },
  { id: 3, name: "Mass" },
]
myAwesomeArray.find(element => element.id === 3)
//-------> Output : {id: 3, name: "Mass"}
myAwesomeArray.find(element => element.id === 7)
//-------> Output : undefined
</pre>
		<pre>
const myAwesomeArray = [5, 4, 3, 2, 1]
// Sort from smallest to largest
myAwesomeArray.sort((a, b) => a - b)
//-------> Output : [1, 2, 3, 4, 5]
// Sort from largest to smallest
myAwesomeArray.sort((a, b) => b - a)
//-------> Output : [5, 4, 3, 2, 1]
</pre>
		<pre>
const myAwesomeArray = [1, 2, 3, 4, 5]
const myAwesomeArray2 = [10, 20, 30, 40, 50]
myAwesomeArray.concat(myAwesomeArray2)
//-------> Output : [1, 2, 3, 4, 5, 10, 20, 30, 40, 50]
</pre>
		<pre>
const myAwesomeArray = [1, 2, 3, 4, 5]
// The first argument (0) is the value
// The second argument (1) is the starting index
// The third argument (3) is the ending index
myAwesomeArray.fill(0, 1, 3)
//-------> Output : [1, 0, 0, 4, 5]
</pre>
		<pre>
const myAwesomeArray = [1, 2, 3, 4, 5]
myAwesomeArray.includes(3)
//-------> Output : true
myAwesomeArray.includes(8)
//-------> Output : false
</pre>
		<pre>
const myAwesomeArray = ["e", "d", "c", "b", "a"]
myAwesomeArray.reverse()
//-------> Output : ['a', 'b', 'c', 'd', 'e']
</pre>
		<pre>
const myAwesomeArray = [[1], [2], [3], [4], [5]]
myAwesomeArray.flatMap(arr => arr * 10)
//-------> Output : [10, 20, 30, 40, 50]
// With .flat() and .map()
myAwesomeArray.flat().map(arr => arr * 10)
//-------> Output : [10, 20, 30, 40, 50]
</pre>
		<pre>
let result = merge([1, 2, 3], [4, 5, 6], [7, 8, 9]);
console.log(result); // выведет [1, 2, 3, 4, 5, 6, 7, 8, 9]</pre>
	</div>


	<h2>Map</h2>
	<div class="main">
		<pre>
let map = new Map;
let arr1 = [1, 2];
let arr2 = [3, 4];

map.set(arr1, 'data1');
map.set(arr2, 'data2');

console.log(map.get(arr1));
console.log(map.get(arr2));

console.log(map.size);
console.log(map.has(arr1));
map.delete(arr1);
map.clear();
</pre>
		<pre>
for (let elem of map) {
	console.log(elem); // сначала [[1, 2], 'data1'], потом [[3, 4], 'data2']
}
</pre>
		<pre>
for (let [key, elem] of map) {
	console.log(key);
	console.log(elem);
}
</pre>
		<pre>
let values = map.values();
let keys = map.keys();
let entries = map.entries();
</pre>
	</div>

	<h2>Set - массивы без дублей</h2>
	<div class="main">
		<pre>
let set = new Set;

set.add(1);
set.add(2);
set.add(3);
set.add(3); // не добавится, т.к. уже есть
</pre>
		<pre>
let set = new Set([1, 2, 3]);
</pre>
		<pre>
console.log(set.size);
console.log(set.has(1));
set.delete(1);
set.clear();
</pre>
		<pre>
let arr = [...set];
let arr = Array.from(set);
</pre>
		<pre>
let arr = [1, 2, 3];
let set = new Set(arr);
</pre>
		<pre>
let arr = [1, 2, 3, 1, 3, 4];
let res = [...new Set(arr)];  [1, 2, 3, 4]
</pre>
	</div>
	
	

	<h2>Symbol</h2>
	<div class="main">
		<pre>
let sym1 = Symbol();
let sym2 = Symbol();
console.log(sym1 === sym2); // false
</pre>
		<pre>
ключи не будут участвовать в переборе циклом.
let obj = {a: 1, b: 2, c: 3};
let sym = Symbol();
obj[sym] = 'text';
</pre>
		<pre>
let obj = {a: 1, b: 2, c: 3};
let sym = Symbol();
obj[sym] = function() {
	console.log('!!!');
};
obj[sym]();
</pre>
		<pre>
Symbol.for сохранены в глобальный реестр символов
let sym = Symbol.for('test');
let key = Symbol.keyFor(sym);
</pre>
	</div>


	<h2>Итераторы</h2>
	<div class="main">
		<pre>
Любой объект, который можно перебрать через цикл for of, называется итерируемым: Массивы, Map, NodeList,
</pre>
		<pre>
let arr = [1, 2, 3];
let func = arr[Symbol.iterator];
console.log(func); // функция
</pre>
		<pre>
let arr = [1, 2, 3];
let iter = arr[Symbol.iterator]();
console.log( iter.next() ); // {value: 1, done: false}
console.log( iter.next() ); // {value: undefined, done: true}
</pre>
		<pre>
Генераторы, с помощью которых можно создавать свои итераторы
function *func() {
	yield 1;
	yield 2;
	yield 3;
}
</pre>
		<pre>
Каждый итератор может участвовать в цикле лишь один раз
а можно несколько раз вот так - 
for (let elem of func()) {
	console.log(elem); // 1, 2, 3
}
</pre>
		<pre>
Итератор объекта
function *func(obj) {
	for (let key in obj) {
		yield obj[key];
	}
}
let iter = func({a: 1, b: 2, c: 3});
</pre>
		<pre>
Создание итерируемого объекта
obj[Symbol.iterator] = function *() {
	for (let key in this) {
		yield obj[key];
	}
}
</pre>
		<pre>
Генератор через вычисляемое свойство
let obj = {
	a: 1,
	b: 2,
	c: 3,
	[Symbol.iterator]: function *(){
		for (let key in this){
			yield this[key];
		}
	}
};
</pre>
		<pre>
Встроенный итератор values

let map = new Map;

map.set('a', 1);
map.set('b', 2);
map.set('c', 3);

let iter = map.values();
</pre>
		<pre>
Встроенный итератор keys

let arr = ['a', 'b', 'c'];
let iter = arr.keys();
for (let elem of iter) {
	console.log(elem); // 0, 1, 2
}
</pre>
		<pre>
Встроенный итератор entries
let arr = ['a', 'b', 'c'];
let iter = arr.entries();
for (let [key, value] of iter) {
	console.log(key);   // 'a', 'b', 'c'
	console.log(value); // 0, 1, 2
}
</pre>
		<pre>
Три встроенных итератора

let map = new Map();
map.set('a', 1);
map.set('b', 2);
map.set('c', 3);

for (let elem of map) {
	console.log(elem); // ['a', 1], ['b', 2], ['c', 3]
}

for (let elem of map.keys()) {
	console.log(elem); // 'a', 'b', 'c'
}

for (let elem of map.values()) {
	console.log(elem); // 1, 2, 3
}
</pre>
		<pre>
Оператор spread и итераторы

let map = new Map();
map.set('a', 1);
map.set('b', 2);
map.set('c', 3);

let arr = [...map];
console.log(arr); // [['a', 1], ['b', 2], ['c', 3]]

let arr = [...map.keys()];
console.log(arr); // ['a', 'b', 'c']

let arr = [...map.values()];
console.log(arr); // [1, 2, 3]
</pre>
		<pre>
Встроенные итераторы строк
console.log([...'abc']); // ['a', 'b', 'c']
</pre>
		<pre>
Массив цифр числа
let num = 12345;
let arr = [...String(num)].map(Number);
console.log(arr); // [1, 2, 3, 4, 5]
</pre>
	</div>



	<h2>JSON</h2>
	<div class="main">
		<pre>
let json = '[1, 2, 3, 4, 5, "a", "b"]';

let json = `{
	"a": "aaa",
	"b": "bbb",
	"c": "ccc",
	"111": "ddd"
}`;

let json = `[
	{
		"a": "aaa",
		"b": "bbb"
	},
	{
		"c": "ccc",
		"d": "ddd"
	}
]`;
</pre>
		<pre>
Преобразование JSON в структуру данных

let json = '[1, 2, 3, 4, 5, "a", "b"]';
let arr = JSON.parse(json);
</pre>
		<pre>
можно преобразовать массивы и объекты JavaScript в формат JSON
let arr = [1, 2, 3, 4, 5, 'a', 'b'];
let json = JSON.stringify(arr);
</pre>
		<pre>
Изменение данных в JSON

let json = '[1, 2, 3, 4, 5]';

let arr  = JSON.parse(json);
arr.push(6);

let res = JSON.stringify(arr);
console.log(res);
</pre>
	</div>


	<h2>Хранилище</h2>
	<div class="main">
<pre>
localStorage.setItem('key', 'text');
let str = localStorage.getItem('key');
console.log(str); // выведет 'text'
</pre>
<pre>
Однократное сохранение
let time = localStorage.getItem('time');
if (!time) {
	let now = Date.now();
	localStorage.setItem('time', now);
}
</pre>
<pre>
Перезапись данных
localStorage.setItem('key', '1');
localStorage.setItem('key', '2');
</pre>
<pre>
Удаление данных
localStorage.removeItem('key');
</pre>
<pre>
Очистка хранилища
localStorage.clear();

</pre>
<pre>
Количество записей

let num = localStorage.length;
</pre>
<pre>
Получение ключа по номеру

let key = localStorage.key(0);
let val = localStorage.getItem(key);
</pre>
<pre>
Перебор хранилища по индексам

for (let i = 0; i < localStorage.length; i++) {
	let key = localStorage.key(i);
	let val = localStorage.getItem(key);
	
	console.log(val);
}
</pre>
<pre>
Массивы ключей и значений
let keys = Object.keys(localStorage);
let values = Object.values(localStorage);
</pre>
<pre>
Хранение структур

let arr = [1, 2, 3, 4, 5];
localStorage.setItem('arr', JSON.stringify(arr));

let str = localStorage.getItem('arr');
let res = JSON.parse(str);

console.log(res);
</pre>
		</div>

	<h2>Исключительные ситуации</h2>
	<div class="main">
<pre>
Перехват
try {
	// код
} catch (error) {
	// обработка ошибки
}
</pre>
<pre>
Выбрасывание исключений
	
</pre>
<pre>

	
</pre>
<pre>

	
</pre>
<pre>

	
</pre>
<pre>

	
</pre>
<pre>

	
</pre>
		</div>

	<h2>Стилизация</h2>
	<div class="main">
		<pre>
let elem = document.querySelector('#elem');
elem.style.color = 'red';
let computedStyle = getComputedStyle(elem);

elem.style.width = '100px';
elem.style.margin = '20px';
elem.style.display = 'block';
	</pre>
		<pre>
elem.style.cssText = `
	width: 100px;
	height: 100px;
	display: block;
`;
</pre>
		<pre>
[data-type="success"] {}
elem.dataset.type = 'success';
</pre>
	</div>


	<h2>Web Technologies</h2>
	<table>
		<tr>
			<td>Серверный рендеринг</td>
			<td>генерирует HTML на сервере и отдаёт пользователю готовый исходный код со всем DOM
		</tr>
		<tr>
			<td>Клиентский</td>
			<td>клиенту отдает JS-бандл</td>
		</tr>
		<tr>
			<td>Прогрессивный</td>
			<td>можно один раз создать себе сайт и выложить его на сервер, где есть только Nginx</td>
		</tr>
		<tr>
			<td>PWA</td>
			<td>мобильное приложение в браузере</td>
		</tr>
		<tr>
			<td>Сетевая модель OSI</td>
			<td>Посредством данной модели различные сетевые устройства могут взаимодействовать друг с другом</td>
		</tr>
		<tr>
			<td>REST</td>
			<td>способ создания API с помощью протокола HTTP</td>
		</tr>
		<tr>
			<td>RESTful API</td>
			<td>интерфейс,используемые двумя компьютерными системами для безопасного обмена информацией через Интернет</td>
		</tr>
		<tr>
			<td>History API</td>
			<td>доступ к управлению историей браузера в рамках текущей сессии</td>
		</tr>
		<tr>
			<td>Local Storage</td>
			<td>Хранит данные бессрочно.
				Очищается только с помощью JavaScript или очистки кэша браузера.
				Хранит данные объёмом до 5 МБ, это самый большой объём из трёх вариантов хранилища.
				Не поддерживается старыми браузерами, например, IE 7 и ниже.
				Работает по правилу ограничения домена (same origin policy). То есть сохранённые данные доступны только для одного источника</td>
		</tr>
		<tr>
			<td>Session Storage</td>
			<td>Хранит данные, пока продолжается текущая сессия. Когда пользователь закрывает браузер, данные становятся недоступными.
				Используется контекст браузера верхнего уровня, поэтому каждая вкладка браузера хранит уникальные данные.
				Объём данных больше чем в Cookie.
				Не поддерживается старыми браузерами, например, IE 7 и ниже.</td>
		</tr>
		<tr>
			<td>Cookie</td>
			<td>Хранит данные, которые можно передавать на сервер через заголовки.
				Локальное и сессионное хранилище доступны только на клиентской стороне.
				Срок хранения устанавливается при создании cookie.
				Объём данных не превышает 4 Кбайт.
				Cookie могут быть защищёнными, в этом случае их содержимое нельзя получить на стороне клиента. Это важно для аутентификации при хранении пользовательских токенов.</td>
		</tr>
		<tr>
			<td>Core Web Vitals</td>
			<td>группа новых факторов ранжирования Google, которые запускаются в мае 2021 года. В эту группу входят 3 параметра: LCP (Largest Contentful Paint) — скорость загрузки основного контента. Основной контент — это самый большой элемент на странице: текст, видео</td>
		</tr>
		<tr>
			<td>метрика Core Web Vitals</td>
			<td>LCP (Largest Contentful Paint) — скорость загрузки основного контента веб-страницы. Основной контент — это самый большой элемент на странице: текст, видео, картинка. Гугл сравнивает разницу между загрузкой основного контента и остальных элементов веб-страницы.

				FID (First Input Delay) — время ожидания до начала взаимодействия пользователя с сайтом. Чем дольше пользователю приходится ждать момента, когда можно начать взаимодействовать со страницей (скролить, кликать по ссылкам, наживать на кнопки) тем ниже лидогенерация и выше показатель отказов.

				CLS (Cumulative Layout Shift) — устойчивость верстки и элементов, которые мешают пользователю взаимодействовать с сайтом. Если в процессе загрузки элементы, особенно кликабельные, смещаются по экрану, пользователь может нажать не на ту кнопку, что не понравится ни пользователю, ни Google.</td>
		</tr>
		<tr>
			<td>PRPL</td>
			<td>это паттерн, рекомендуемый командой разработчиков Chrome для организации поэтапной загрузки кода. Он рассчитан на то, чтобы приложения, использующие его, как можно быстрее становились бы интерактивными на дешёвых устройствах и в медленных сетях. Паттерн PRPL поощряет предварительную загрузку минимального объёма JS-кода, необходимого для того, чтобы со страницей можно было бы работать. Затем ресурсы загружаются с использованием методик ленивой загрузки. Если нужно — можно воспользоваться сервис-воркером для предварительного кэширования JavaScript-ресурсов, необходимых для будущих взаимодействий с сайтом.</td>
		</tr>
	</table>

	<h2 class="accordion">Web API</h2>
	<table>
		<tr>
			<td>HTTP-запрос</td>
			<td>для передачи гипертекстовых документов, то есть документов, которые могут содержать ссылки, позволяющие организовать переход к другим документам</td>
		</tr>
		<tr>
			<td>Какие методы может иметь HTTP-запрос?</td>
			<td>OPTIONS.
				GET.
				HEAD.
				POST.
				PUT.
				PATCH.
				DELETE.
				TRACE.</td>
		</tr>
		<tr>
			<td>HTTP/2</td>
			<td>двоичный уровень кадрирования</td>
		</tr>
		<tr>
			<td>мультиплексирование в HTTP/2</td>
			<td>множество запросов в рамках одного TCP-соединения</td>
		</tr>
		<tr>
			<td>трехстороннее рукопожатие Triple handshake</td>
			<td>соединения между локальным хостом/клиентом и сервером</td>
		</tr>
		<tr>
			<td>PUT запрос</td>
			<td>должен быть задан уникальный ID указанного ресурса</td>
		</tr>
		<tr>
			<td>TCP и UDP</td>
			<td>TCP предполагает потоковую передачу данных, границы фрагментов данных не обозначены. UDP использует метод датаграмм, когда получатель проверяет целостность пакетов лишь при получении сообщения</td>
		</tr>
		<tr>
			<td>WebSocket</td>
			<td>двунаправленный протокол связи между клиентом (браузером) и сервером, позволяющий обмениваться сообщениями в режиме реального времени.</td>
		</tr>
		<tr>
			<td>Long Polling</td>
			<td>процесс, при котором соединение между сервером и клиентом не разрывается длительный период, а при разрыве повторно создается.</td>
		</tr>
		<tr>
			<td>Server Sent Events</td>
			<td>Идеально подойдет для динамически изменяемой информации в приложении. Например, различная real-time статистика, текстовые трансляции матчей и так далее</td>
		</tr>
		<tr>
			<td>JSONP</td>
			<td>JSONP работает путем внедрения тега script на страницу, который загружает файл JSON с сервера и обрабатывает его с помощью пользовательской функции.</td>
		</tr>
		<tr>
			<td>IndexedDB</td>
			<td>IndexedDB — это механизм, который позволяет хранить большие объемы данных на клиентской стороне, где браузер обладает доступом к файловой системе пользователя</td>
		</tr>
		<tr>
			<td>Service Workers</td>
			<td>скрипт, который работает в фоновом режиме, независимо от веб-страницы</td>
		</tr>
		<tr>
			<td>Web Workers</td>
			<td>ресурсоёмкие вычисления могут выполняться в отдельном потоке</td>
		</tr>
		<tr>
			<td>SSL/TLS</td>
			<td>цифровой объект, который позволяет системам проверять личность и впоследствии устанавливать зашифрованное сетевое соединение с другой системой</td>
		</tr>
		<tr>
			<td>CDN</td>
			<td>это географически распределённая сетевая инфраструктура</td>
		</tr>
		<tr>
			<td>IP-адрес</td>
			<td>это уникальный адрес, идентифицирующий устройство в интернете или локальной сети</td>
		</tr>
		<tr>
			<td>Доменные имена, Хостинг</td>
			<td>который вводят пользователи, чтобы зайти на сайт, место размещения веб-сайтов на серверах.</td>
		</tr>
		<tr>
			<td>URL</td>
			<td>Uniform Resource Locator (унифицированный определитель местонахождения ресурса)</td>
		</tr>
		<tr>
			<td>URN</td>
			<td>Unifrorm Resource Name (унифицированное имя ресурса)</td>
		</tr>
		<tr>
			<td>Идентификация</td>
			<td>процедура, в результате выполнения которой для субъекта идентификации выявляется его идентификатор, однозначно определяющий этого субъекта в информационной системе.</td>
		</tr>
		<tr>
			<td>Аутентификация</td>
			<td>процедура проверки подлинности, например проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных.</td>
		</tr>
		<tr>
			<td>Авторизация</td>
			<td>предоставление определенному лицу или группе лиц прав на выполнение определенных действий.</td>
		</tr>
		<tr>
			<td>Виды аутентификации</td>
			<td>электронной подписи,по паролям,SMS,Биометрическая аутентификация,географическое местоположение,Многофакторная аутентификация</td>
		</tr>
		<tr>
			<td>(Secure) и HttpOnly cookies</td>
			<td>Атрибут secure и флаг httpOnly работают вместе, чтобы гарантировать, что браузер может ограничить доступ к защищенным данным cookie из вредоносных скриптов, которые могли заразить браузер или сеть.</td>
		</tr>
		<tr>
			<td>Content Security Policy</td>
			<td>дополнительный уровень безопасности, позволяющий распознавать и устранять определённые типы атак, таких как Cross Site Scripting</td>
		</tr>
		<tr>
			<td>Cross-Origin Resource Sharing</td>
			<td>использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент.</td>
		</tr>
		<tr>
			<td>XSS</td>
			<td>тип атаки на веб-системы, заключающийся во внедрении в выдаваемую веб-системой страницу вредоносного кода</td>
		</tr>
		<tr>
			<td>Методы повышения безопасности веб-приложений</td>
			<td>проверка данных на соответствие стандартам протоколов;
				контроль трафика на основе нейронных сетей;
				сигнатурный анализ;
				защита от SQL-инъекций;
				протекция от межсетевого скриптинга (XSS);
				контроль доступа к конфиденциальным данным.</td>
		</tr>
		<tr>
			<td>OWASP</td>
			<td>это стандартный информационный документ для разработчиков и безопасности веб-приложений</td>
		</tr>
		<tr>
			<td>композиция и наследование</td>
			<td>композиция даёт возможность переиспользовать код без расширения существующего класса, как это происходит в случае с наследованием</td>
		</tr>
		<tr>
			<td>Шаблон проектирования</td>
			<td>(паттерн, от англ. design pattern) — повторяемая архитектурная конструкция в сфере проектирования программного обеспечения, предлагающая решение проблемы проектирования в рамках некоторого часто возникающего контекста.</td>
		</tr>
		<tr>
			<td>Полиморфизм</td>
			<td>способность функции работать с данными разных типов</td>
		</tr>
		<tr>
			<td>Абстрактные классы в объектно-ориентированном программировании</td>
			<td>базовые классы, которые можно наследовать, но нельзя реализовывать. То есть на их основе нельзя создать объект</td>
		</tr>
		<tr>
			<td>JavaScript каждый объект имеет объект-прототип</td>
			<td>В свою очередь этот объект-прототип может содержать в себе другой прототип и наследовать свойства уже от него. В итоге объект-экземпляр получает доступ ко всей цепочке прототипов и их свойствам и методам.</td>
		</tr>
		<tr>
			<td>Реактивное программирование</td>
			<td>парадигма программирования, ориентированная на потоки данных и распространение изменений. Это означает, что должна существовать возможность легко выражать статические и динамические потоки данных, а также то, что нижележащая модель исполнения должна автоматически распространять изменения благодаря потоку данных.</td>
		</tr>
		<tr>
			<td>Inversion of Control</td>
			<td>каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других компонентов.</td>
		</tr>
	</table>

	<h2>OOP & FP (вопросы из объектно-ориентированного и функционального программирования)</h2>
	<table>
		<tr>
			<td>ООП</td>
			<td>
				<ul>
					<li>Инкапсулируйте все, что может изменяться;</li>
					<li>Уделяйте больше внимания интерфейсам, а не их реализациям;</li>
					<li>Каждый класс в вашем приложении должен иметь только одно назначение;</li>
					<li>Классы — это их поведение и функциональность.</li>
				</ul>
			</td>
		</tr>
		<tr>
			<td>Абстракция</td>
			<td>отделение концепции от ее экземпляра</td>
		</tr>
		<tr>
			<td>Полиморфизм</td>
			<td>реализация задач одной и той же идеи разными способами</td>
		</tr>
		<tr>
			<td>Наследование</td>
			<td>способность объекта или класса базироваться на другом объекте или классе</td>
		</tr>
		<tr>
			<td>Инкапсуляция</td>
			<td>размещение одного объекта или класса внутри другого для разграничения доступа к ним</td>
		</tr>
		<tr>
			<td>Делегация</td>
			<td>перепоручение задачи от внешнего объекта внутреннему</td>
		</tr>
		<tr>
			<td>Композиция</td>
			<td>включение объектом-контейнером объекта-содержимого и управление его поведением; последний не может существовать вне первого
			</td>
		</tr>
		<tr>
			<td>Агрегация</td>
			<td>включение объектом-контейнером ссылки на объект-содержимое; при уничтожении первого последний продолжает существование
			</td>
		</tr>
		<tr>
			<td>DRY</td>
			<td>Не повторяйся</td>
		</tr>
		<tr>
			<td>Принцип единственной обязанности</td>
			<td>Для каждого класса должно быть определено единственное назначение</td>
		</tr>
		<tr>
			<td>Принцип открытости/закрытости</td>
			<td>Программные сущности должны быть открыты для расширения, но закрыты для изменений</td>
		</tr>
		<tr>
			<td>Принцип подстановки Барбары Лисков</td>
			<td>Методы, использующие некий тип, должны иметь возможность использовать его подтипы, не зная об этом</td>
		</tr>
		<tr>
			<td>Принцип разделения интерфейсов</td>
			<td> Предпочтительнее разделять интерфейсы на более мелкие тематические, чтобы реализующие их классы не были вынуждены определять методы, которые непосредственно в них не используются</td>
		</tr>
		<tr>
			<td>Принцип инверсии зависимостей</td>
			<td>Система должна конструироваться на основе абстракций «сверху вниз»: не абстракции должны формироваться на основе деталей, а детали должны формироваться на основе абстракций</td>
		</tr>
		<tr>
			<td>SOLID</td>
			<td>принципы объектно‑ориентированного программирования</td>
		</tr>
		<tr>
			<td>Классовое наследование</td>
			<td>экземпляры наследуются от классов, создаются подклассовые отношения</td>
		</tr>
		<tr>
			<td>лучше использовать прототипное наследование</td>
			<td>Делегирование (цепочка прототипов)
				Конкатенация (миксины, Object.assign())
				Функциональное наследование (не путать с функциональным программированием. Функция используется для создания замыкания для private/инкапсуляции)</td>
		</tr>
		<tr>
			<td>Двусторонняя связь данных</td>
			<td>поля интерфейса связаны с моделью данных динамически, то есть при изменении полей интерфейса меняется модель, и наоборот</td>
		</tr>
		<tr>
			<td>Функциональное программирование</td>
			<td>подразумевает вычисление математических функций, избегая общих состояний и изменяемых данных</td>
		</tr>
		<tr>
			<td>MVC</td>
			<td>способ организации кода, который предполагает выделение блоков, отвечающих за решение разных задач</td>
		</tr>
		<tr>
			<td>MVVM</td>
			<td>паттерн разработки, позволяющий разделить приложение на три функциональные части:

				Model — основная логика программы (работа с данными, вычисления, запросы и так далее)
				View — вид или представление (пользовательский интерфейс)
				ViewModel — модель представления, которая служит прослойкой между View и Mode</td>
		</tr>
		<tr>
			<td>Minimal Viable Product</td>
			<td>тестовая версия товара, услуги или сервиса с минимальным набором функций (иногда даже одной), которая несет ценность для конечного потребителя</td>
		</tr>
		<tr>
			<td>Метод</td>
			<td>функция или процедура, которая принадлежит классу или экземпляру класса</td>
		</tr>
		<tr>
			<td>Каррирование</td>
			<td>f(a, b, c), а как f(a)(b)(c)</td>
		</tr>
		<tr>
			<td>Монолитная архитектура</td>
			<td>отдельная большая вычислительная сеть с единой базой кода, в которой объединены все бизнес-задачи</td>
		</tr>
		<tr>
			<td>Микросервисная архитектура</td>
			<td>метод организации архитектуры, основанный на ряде независимо развертываемых служб</td>
		</tr>
		<tr>
			<td>дескрипторы</td>
			<td>пары ключ-значение, которые описывают поведение свойства объекта при выполнении операций над ним (например, чтения или записи)</td>
		</tr>
		<tr>
			<td>Геттеры и сеттеры</td>
			<td>аксессоры или вычисляемые свойства. Это методы, имитирующие поля, но позволяющие читать и записывать данные. Геттеры используются для получения данных, сеттеры — для их изменения</td>
		</tr>
	</table>


	<a href="https://learn.javascript.ru/prototype-inheritance" target="_blank">Прототипное наследование</a>
	<pre>
rabbit.__proto__ = animal;
	</pre>

	<a href="https://learn.javascript.ru/function-prototype" target="_blank">F.prototype</a>
	<pre>
let rabbit = new Rabbit("White Rabbit");
</pre>

	<a href="https://learn.javascript.ru/native-prototypes" target="_blank">Встроенные прототипы</a>
	<pre>
obj.__proto__ === Object.prototype

String.prototype.show = function() {
  alert(this);
};

"BOOM!".show(); // BOOM!
</pre>

	<a href="https://learn.javascript.ru/prototype-methods" target="_blank">Методы прототипов, объекты без свойства __proto__</a>
	<pre>
Object.create(proto, [descriptors])
Object.getPrototypeOf(obj)
Object.setPrototypeOf(obj, proto)
</pre>

	<a href="https://learn.javascript.ru/callbacks" target="_blank">колбэки</a>
	<pre>
function loadScript(src, callback) {
	script.onload = () => callback(script);
}

script.onload = () => callback(null, script);
script.onerror = () => callback(new Error(`Не удалось загрузить скрипт ${src}`));
</pre>

	<a href="https://learn.javascript.ru/promise-basics" target="_blank">Промисы</a>
	<pre>
let promise = new Promise(function(resolve, reject) {
});

promise.then(
  result => alert(result), // не будет запущена
  error => alert(error) // выведет "Error: Whoops!" спустя одну секунду
);

promise.catch(alert);

.finally(() => остановить индикатор загрузки)
 
 
</pre>

	<a href="https://learn.javascript.ru/promise-api" target="_blank">Promise API</a>
	<pre>
let promise = Promise.all(iterable);

let promise = Promise.allSettled(iterable);

let promise = Promise.race(iterable);

let promise = Promise.any(iterable);
</pre>

	<a href="https://learn.javascript.ru/async-await" target="_blank">Async/await</a>
	<pre>
функция в любом случае вернёт промис

async function f() {
  return 1;
}
f().then(alert); // 1

await, которое можно использовать только внутри

async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("готово!"), 1000)
  });

  let result = await promise; // будет ждать, пока промис не выполнится (*)

  alert(result); // "готово!"
}

f();


async function f() {

  try {
    let response = await fetch('http://no-such-url');
  } catch(err) {
    alert(err); // TypeError: failed to fetch
  }
}

f();
</pre>

	<a href="https://learn.javascript.ru/generators" target="_blank">Генераторы</a>
	<pre>
Генераторы отлично работают с перебираемыми объектами и позволяют легко создавать потоки данных

function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}
</pre>

	<a href="" target="_blank"></a>
	<pre>

</pre>

	<a href="" target="_blank"></a>
	<pre>

</pre>

	<a href="" target="_blank"></a>
	<pre>

</pre>

	<a href="" target="_blank"></a>
	<pre>

</pre>
</body>

</html>
