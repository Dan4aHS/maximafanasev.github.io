<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Title</title>
	<link rel="stylesheet" href="main.css">
</head>

<body>
	<h1>Все знания по js в 1 месте</h1>
	<ol>
		<li><a href="#oopfpweb">Web Technologies, Web API, OOP & FP</a></li>
		<li><a href="#html">HTML</a></li>
		<li><a href="#basics">Основы</a></li>
		<li><a href="#strings">Строки</a></li>
		<li><a href="#arrays">Массивы</a></li>
		<li><a href="#objects">Объекты</a></li>
		<li><a href="#functions">Функции</a></li>
		<li><a href="#dom">Дом</a></li>

		</li>
		<li><a href="practice.html">Практика</a></li>
	</ol>


	<h2 id="oopfpweb">Web Technologies</h2>
	<table>
		<tr>
			<td>рендеринг</td>
			<td>
		</tr>
		<tr>
			<td>Клиентский</td>
			<td>клиенту отдает JS-бандл</td>
		</tr>
		<tr>
			<td>Прогрессивный</td>
			<td>можно один раз создать себе сайт и выложить его на сервер, где есть только Nginx</td>
		</tr>
		<tr>
			<td>PWA</td>
			<td>мобильное приложение в браузере</td>
		</tr>
		<tr>
			<td>Сетевая модель OSI</td>
			<td>Посредством данной модели различные сетевые устройства могут взаимодействовать друг с другом</td>
		</tr>
		<tr>
			<td>REST</td>
			<td>способ создания API с помощью протокола HTTP</td>
		</tr>
		<tr>
			<td>RESTful API</td>
			<td>интерфейс,используемые двумя компьютерными системами для безопасного обмена информацией через Интернет</td>
		</tr>
		<tr>
			<td>History API</td>
			<td>доступ к управлению историей браузера в рамках текущей сессии</td>
		</tr>
		<tr>
			<td>Local Storage</td>
			<td>Хранит данные бессрочно.
				Очищается только с помощью JavaScript или очистки кэша браузера.
				Хранит данные объёмом до 5 МБ, это самый большой объём из трёх вариантов хранилища.
				Не поддерживается старыми браузерами, например, IE 7 и ниже.
				Работает по правилу ограничения домена (same origin policy). То есть сохранённые данные доступны только для одного источника</td>
		</tr>
		<tr>
			<td>Session Storage</td>
			<td>Хранит данные, пока продолжается текущая сессия. Когда пользователь закрывает браузер, данные становятся недоступными.
				Используется контекст браузера верхнего уровня, поэтому каждая вкладка браузера хранит уникальные данные.
				Объём данных больше чем в Cookie.
				Не поддерживается старыми браузерами, например, IE 7 и ниже.</td>
		</tr>
		<tr>
			<td>Cookie</td>
			<td>Хранит данные, которые можно передавать на сервер через заголовки.
				Локальное и сессионное хранилище доступны только на клиентской стороне.
				Срок хранения устанавливается при создании cookie.
				Объём данных не превышает 4 Кбайт.
				Cookie могут быть защищёнными, в этом случае их содержимое нельзя получить на стороне клиента. Это важно для аутентификации при хранении пользовательских токенов.</td>
		</tr>
		<tr>
			<td>Core Web Vitals</td>
			<td>группа новых факторов ранжирования Google, которые запускаются в мае 2021 года. В эту группу входят 3 параметра: LCP (Largest Contentful Paint) — скорость загрузки основного контента. Основной контент — это самый большой элемент на странице: текст, видео</td>
		</tr>
		<tr>
			<td>метрика Core Web Vitals</td>
			<td>LCP (Largest Contentful Paint) — скорость загрузки основного контента веб-страницы. Основной контент — это самый большой элемент на странице: текст, видео, картинка. Гугл сравнивает разницу между загрузкой основного контента и остальных элементов веб-страницы.

				FID (First Input Delay) — время ожидания до начала взаимодействия пользователя с сайтом. Чем дольше пользователю приходится ждать момента, когда можно начать взаимодействовать со страницей (скролить, кликать по ссылкам, наживать на кнопки) тем ниже лидогенерация и выше показатель отказов.

				CLS (Cumulative Layout Shift) — устойчивость верстки и элементов, которые мешают пользователю взаимодействовать с сайтом. Если в процессе загрузки элементы, особенно кликабельные, смещаются по экрану, пользователь может нажать не на ту кнопку, что не понравится ни пользователю, ни Google.</td>
		</tr>
		<tr>
			<td>PRPL</td>
			<td>это паттерн, рекомендуемый командой разработчиков Chrome для организации поэтапной загрузки кода. Он рассчитан на то, чтобы приложения, использующие его, как можно быстрее становились бы интерактивными на дешёвых устройствах и в медленных сетях. Паттерн PRPL поощряет предварительную загрузку минимального объёма JS-кода, необходимого для того, чтобы со страницей можно было бы работать. Затем ресурсы загружаются с использованием методик ленивой загрузки. Если нужно — можно воспользоваться сервис-воркером для предварительного кэширования JavaScript-ресурсов, необходимых для будущих взаимодействий с сайтом.</td>
		</tr>
	</table>

	<h2 id="" class="accordion">Web API</h2>
	<table>
		<tr>
			<td>HTTP-запрос</td>
			<td>для передачи гипертекстовых документов, то есть документов, которые могут содержать ссылки, позволяющие организовать переход к другим документам</td>
		</tr>
		<tr>
			<td>Какие методы может иметь HTTP-запрос?</td>
			<td>OPTIONS.
				GET.
				HEAD.
				POST.
				PUT.
				PATCH.
				DELETE.
				TRACE.</td>
		</tr>
		<tr>
			<td>HTTP/2</td>
			<td>двоичный уровень кадрирования</td>
		</tr>
		<tr>
			<td>мультиплексирование в HTTP/2</td>
			<td>множество запросов в рамках одного TCP-соединения</td>
		</tr>
		<tr>
			<td>трехстороннее рукопожатие Triple handshake</td>
			<td>соединения между локальным хостом/клиентом и сервером</td>
		</tr>
		<tr>
			<td>PUT запрос</td>
			<td>должен быть задан уникальный ID указанного ресурса</td>
		</tr>
		<tr>
			<td>TCP и UDP</td>
			<td>TCP предполагает потоковую передачу данных, границы фрагментов данных не обозначены. UDP использует метод датаграмм, когда получатель проверяет целостность пакетов лишь при получении сообщения</td>
		</tr>
		<tr>
			<td>WebSocket</td>
			<td>двунаправленный протокол связи между клиентом (браузером) и сервером, позволяющий обмениваться сообщениями в режиме реального времени.</td>
		</tr>
		<tr>
			<td>Long Polling</td>
			<td>процесс, при котором соединение между сервером и клиентом не разрывается длительный период, а при разрыве повторно создается.</td>
		</tr>
		<tr>
			<td>Server Sent Events</td>
			<td>Идеально подойдет для динамически изменяемой информации в приложении. Например, различная real-time статистика, текстовые трансляции матчей и так далее</td>
		</tr>
		<tr>
			<td>JSONP</td>
			<td>JSONP работает путем внедрения тега script на страницу, который загружает файл JSON с сервера и обрабатывает его с помощью пользовательской функции.</td>
		</tr>
		<tr>
			<td>IndexedDB</td>
			<td>IndexedDB — это механизм, который позволяет хранить большие объемы данных на клиентской стороне, где браузер обладает доступом к файловой системе пользователя</td>
		</tr>
		<tr>
			<td>Service Workers</td>
			<td>скрипт, который работает в фоновом режиме, независимо от веб-страницы</td>
		</tr>
		<tr>
			<td>Web Workers</td>
			<td>ресурсоёмкие вычисления могут выполняться в отдельном потоке</td>
		</tr>
		<tr>
			<td>SSL/TLS</td>
			<td>цифровой объект, который позволяет системам проверять личность и впоследствии устанавливать зашифрованное сетевое соединение с другой системой</td>
		</tr>
		<tr>
			<td>CDN</td>
			<td>это географически распределённая сетевая инфраструктура</td>
		</tr>
		<tr>
			<td>IP-адрес</td>
			<td>это уникальный адрес, идентифицирующий устройство в интернете или локальной сети</td>
		</tr>
		<tr>
			<td>Доменные имена, Хостинг</td>
			<td>который вводят пользователи, чтобы зайти на сайт, место размещения веб-сайтов на серверах.</td>
		</tr>
		<tr>
			<td>URL</td>
			<td>Uniform Resource Locator (унифицированный определитель местонахождения ресурса)</td>
		</tr>
		<tr>
			<td>URN</td>
			<td>Unifrorm Resource Name (унифицированное имя ресурса)</td>
		</tr>
		<tr>
			<td>Идентификация</td>
			<td>процедура, в результате выполнения которой для субъекта идентификации выявляется его идентификатор, однозначно определяющий этого субъекта в информационной системе.</td>
		</tr>
		<tr>
			<td>Аутентификация</td>
			<td>процедура проверки подлинности, например проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных.</td>
		</tr>
		<tr>
			<td>Авторизация</td>
			<td>предоставление определенному лицу или группе лиц прав на выполнение определенных действий.</td>
		</tr>
		<tr>
			<td>Виды аутентификации</td>
			<td>электронной подписи,по паролям,SMS,Биометрическая аутентификация,географическое местоположение,Многофакторная аутентификация</td>
		</tr>
		<tr>
			<td>(Secure) и HttpOnly cookies</td>
			<td>Атрибут secure и флаг httpOnly работают вместе, чтобы гарантировать, что браузер может ограничить доступ к защищенным данным cookie из вредоносных скриптов, которые могли заразить браузер или сеть.</td>
		</tr>
		<tr>
			<td>Content Security Policy</td>
			<td>дополнительный уровень безопасности, позволяющий распознавать и устранять определённые типы атак, таких как Cross Site Scripting</td>
		</tr>
		<tr>
			<td>Cross-Origin Resource Sharing</td>
			<td>использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент.</td>
		</tr>
		<tr>
			<td>XSS</td>
			<td>тип атаки на веб-системы, заключающийся во внедрении в выдаваемую веб-системой страницу вредоносного кода</td>
		</tr>
		<tr>
			<td>Методы повышения безопасности веб-приложений</td>
			<td>проверка данных на соответствие стандартам протоколов;
				контроль трафика на основе нейронных сетей;
				сигнатурный анализ;
				защита от SQL-инъекций;
				протекция от межсетевого скриптинга (XSS);
				контроль доступа к конфиденциальным данным.</td>
		</tr>
		<tr>
			<td>OWASP</td>
			<td>это стандартный информационный документ для разработчиков и безопасности веб-приложений</td>
		</tr>
		<tr>
			<td>композиция и наследование</td>
			<td>композиция даёт возможность переиспользовать код без расширения существующего класса, как это происходит в случае с наследованием</td>
		</tr>
		<tr>
			<td>Шаблон проектирования</td>
			<td>(паттерн, от англ. design pattern) — повторяемая архитектурная конструкция в сфере проектирования программного обеспечения, предлагающая решение проблемы проектирования в рамках некоторого часто возникающего контекста.</td>
		</tr>
		<tr>
			<td>Полиморфизм</td>
			<td>способность функции работать с данными разных типов</td>
		</tr>
		<tr>
			<td>Абстрактные классы в объектно-ориентированном программировании</td>
			<td>базовые классы, которые можно наследовать, но нельзя реализовывать. То есть на их основе нельзя создать объект</td>
		</tr>
		<tr>
			<td>JavaScript каждый объект имеет объект-прототип</td>
			<td>В свою очередь этот объект-прототип может содержать в себе другой прототип и наследовать свойства уже от него. В итоге объект-экземпляр получает доступ ко всей цепочке прототипов и их свойствам и методам.</td>
		</tr>
		<tr>
			<td>Реактивное программирование</td>
			<td>парадигма программирования, ориентированная на потоки данных и распространение изменений. Это означает, что должна существовать возможность легко выражать статические и динамические потоки данных, а также то, что нижележащая модель исполнения должна автоматически распространять изменения благодаря потоку данных.</td>
		</tr>
		<tr>
			<td>Inversion of Control</td>
			<td>каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других компонентов.</td>
		</tr>
	</table>

	<h2 id="">OOP & FP (вопросы из объектно-ориентированного и функционального программирования)</h2>
	<table>
		<tr>
			<td>ООП</td>
			<td>
				<ul>
					<li>Инкапсулируйте все, что может изменяться;</li>
					<li>Уделяйте больше внимания интерфейсам, а не их реализациям;</li>
					<li>Каждый класс в вашем приложении должен иметь только одно назначение;</li>
					<li>Классы — это их поведение и функциональность.</li>
				</ul>
			</td>
		</tr>
		<tr>
			<td>Абстракция</td>
			<td>отделение концепции от ее экземпляра</td>
		</tr>
		<tr>
			<td>Полиморфизм</td>
			<td>реализация задач одной и той же идеи разными способами</td>
		</tr>
		<tr>
			<td>Наследование</td>
			<td>способность объекта или класса базироваться на другом объекте или классе</td>
		</tr>
		<tr>
			<td>Инкапсуляция</td>
			<td>размещение одного объекта или класса внутри другого для разграничения доступа к ним</td>
		</tr>
		<tr>
			<td>Делегация</td>
			<td>перепоручение задачи от внешнего объекта внутреннему</td>
		</tr>
		<tr>
			<td>Композиция</td>
			<td>включение объектом-контейнером объекта-содержимого и управление его поведением; последний не может существовать вне первого
			</td>
		</tr>
		<tr>
			<td>Агрегация</td>
			<td>включение объектом-контейнером ссылки на объект-содержимое; при уничтожении первого последний продолжает существование
			</td>
		</tr>
		<tr>
			<td>DRY</td>
			<td>Не повторяйся</td>
		</tr>
		<tr>
			<td>Принцип единственной обязанности</td>
			<td>Для каждого класса должно быть определено единственное назначение</td>
		</tr>
		<tr>
			<td>Принцип открытости/закрытости</td>
			<td>Программные сущности должны быть открыты для расширения, но закрыты для изменений</td>
		</tr>
		<tr>
			<td>Принцип подстановки Барбары Лисков</td>
			<td>Методы, использующие некий тип, должны иметь возможность использовать его подтипы, не зная об этом</td>
		</tr>
		<tr>
			<td>Принцип разделения интерфейсов</td>
			<td> Предпочтительнее разделять интерфейсы на более мелкие тематические, чтобы реализующие их классы не были вынуждены определять методы, которые непосредственно в них не используются</td>
		</tr>
		<tr>
			<td>Принцип инверсии зависимостей</td>
			<td>Система должна конструироваться на основе абстракций «сверху вниз»: не абстракции должны формироваться на основе деталей, а детали должны формироваться на основе абстракций</td>
		</tr>
		<tr>
			<td>SOLID</td>
			<td>принципы объектно‑ориентированного программирования</td>
		</tr>
		<tr>
			<td>Классовое наследование</td>
			<td>экземпляры наследуются от классов, создаются подклассовые отношения</td>
		</tr>
		<tr>
			<td>лучше использовать прототипное наследование</td>
			<td>Делегирование (цепочка прототипов)
				Конкатенация (миксины, Object.assign())
				Функциональное наследование (не путать с функциональным программированием. Функция используется для создания замыкания для private/инкапсуляции)</td>
		</tr>
		<tr>
			<td>Двусторонняя связь данных</td>
			<td>поля интерфейса связаны с моделью данных динамически, то есть при изменении полей интерфейса меняется модель, и наоборот</td>
		</tr>
		<tr>
			<td>Функциональное программирование</td>
			<td>подразумевает вычисление математических функций, избегая общих состояний и изменяемых данных</td>
		</tr>
		<tr>
			<td>MVC</td>
			<td>способ организации кода, который предполагает выделение блоков, отвечающих за решение разных задач</td>
		</tr>
		<tr>
			<td>MVVM</td>
			<td>паттерн разработки, позволяющий разделить приложение на три функциональные части:

				Model — основная логика программы (работа с данными, вычисления, запросы и так далее)
				View — вид или представление (пользовательский интерфейс)
				ViewModel — модель представления, которая служит прослойкой между View и Mode</td>
		</tr>
		<tr>
			<td>Minimal Viable Product</td>
			<td>тестовая версия товара, услуги или сервиса с минимальным набором функций (иногда даже одной), которая несет ценность для конечного потребителя</td>
		</tr>
		<tr>
			<td>Метод</td>
			<td>функция или процедура, которая принадлежит классу или экземпляру класса</td>
		</tr>
		<tr>
			<td>Каррирование</td>
			<td>f(a, b, c), а как f(a)(b)(c)</td>
		</tr>
		<tr>
			<td>Монолитная архитектура</td>
			<td>отдельная большая вычислительная сеть с единой базой кода, в которой объединены все бизнес-задачи</td>
		</tr>
		<tr>
			<td>Микросервисная архитектура</td>
			<td>метод организации архитектуры, основанный на ряде независимо развертываемых служб</td>
		</tr>
		<tr>
			<td>дескрипторы</td>
			<td>пары ключ-значение, которые описывают поведение свойства объекта при выполнении операций над ним (например, чтения или записи)</td>
		</tr>
		<tr>
			<td>Геттеры и сеттеры</td>
			<td>аксессоры или вычисляемые свойства. Это методы, имитирующие поля, но позволяющие читать и записывать данные. Геттеры используются для получения данных, сеттеры — для их изменения</td>
		</tr>
	</table>

	<h2 id="basics">Основы</h2>
	<pre>
script src="script.js?v=1"
str, my_str, myStr, a1, $, $a, $$a
alert(10 % 3); // выведет 1
alert(10 ** 3); // выведет 1000
undefined, null, true, false, NaN, Infinity, -Infinity
Math.pow Math.sqrt
Math.round Math.ceil Math.floor toFixed toPrecision
Math.max Math.min
Math.random
Math.abs
	</pre>
	
	<h2>Числа</h2>
<pre>
IEEE-754
let billion = 1e9
let a = 0b11111111 8e
num.toString(base)
</pre>

	<h2 id="strings">Строки</h2>
	<pre>
...'abcde' // 'a','b','c','d','e'
str.toLowerCase() и str.toUpperCase()
str.slice
startsWith, endsWith
~2
str.codePointAt(pos)
str.concat
str.includes
str.indexOf
str.search
str.replace
str.padEnd str.padStart
str.trim
str.charCodeAt
</pre>

	<h2 id="arrays">Массивы методы</h2>
<pre>
let arr = [2025, 12, 31];
let [year, month, day] = arr;


let arr1 = ['a', 'b', 'c'];
let arr2 = [1, ...arr1, 2, 3];
console.log(arr2); // выведет [1, 'a', 'b', 'c', 2, 3]


func(1, 2, 3, 4, 5);
function func(a, b, ...rest) {
    console.log(a);    // выведет 1
    console.log(b);    // выведет 2
    console.log(rest); // выведет [3, 4, 5]
}
</pre>
	<pre>
const myAwesomeArray = ["a", "b", "c", "d", "e"]
myAwesomeArray.some(test => test === "d")
//-------> Output : true


const myAwesomeArray = [1, 2, 3, 4, 5]
myAwesomeArray.reduce((total, value) => total * value)
// 1 * 2 * 3 * 4 * 5
//-------> Output = 120


const myAwesomeArray = ["a", "b", "c", "d", "e"]
myAwesomeArray.every(test => test === "d")
//-------> Output : false
const myAwesomeArray2 = ["a", "a", "a", "a", "a"]
myAwesomeArray2.every(test => test === "a")
//-------> Output : true


const myAwesomeArray = [5, 4, 3, 2, 1]
myAwesomeArray.map(x => x * x)
//-------> Output : 25
//                  16
//                  9
//                  4
//                  1


const myAwesomeArray = [[1, 2], [3, 4], 5]
myAwesomeArray.flat()
//-------> Output : [1, 2, 3, 4, 5]


const myAwesomeArray = [
  { id: 1, name: "john" },
  { id: 2, name: "Ali" },
  { id: 3, name: "Mass" },
  { id: 4, name: "Mass" },
]
myAwesomeArray.filter(element => element.name === "Mass")
//-------> Output : 0:{id: 3, name: "Mass"},
//                  1:{id: 4, name: "Mass"}


const myAwesomeArray = [
  { id: 1, name: "john" },
  { id: 2, name: "Ali" },
  { id: 3, name: "Mass" },
]
myAwesomeArray.forEach(element => console.log(element.name))
//-------> Output : john
//                  Ali
//                  Mass


const myAwesomeArray = [
  { id: 1, name: "john" },
  { id: 2, name: "Ali" },
  { id: 3, name: "Mass" },
]
myAwesomeArray.findIndex(element => element.id === 3)
//-------> Output : 2
myAwesomeArray.findIndex(element => element.id === 7)
//-------> Output : -1


const myAwesomeArray = [
  { id: 1, name: "john" },
  { id: 2, name: "Ali" },
  { id: 3, name: "Mass" },
]
myAwesomeArray.find(element => element.id === 3)
//-------> Output : {id: 3, name: "Mass"}
myAwesomeArray.find(element => element.id === 7)
//-------> Output : undefined


const myAwesomeArray = [5, 4, 3, 2, 1]
// Sort from smallest to largest
myAwesomeArray.sort((a, b) => a - b)
//-------> Output : [1, 2, 3, 4, 5]
// Sort from largest to smallest
myAwesomeArray.sort((a, b) => b - a)
//-------> Output : [5, 4, 3, 2, 1]


const myAwesomeArray = [1, 2, 3, 4, 5]
const myAwesomeArray2 = [10, 20, 30, 40, 50]
myAwesomeArray.concat(myAwesomeArray2)
//-------> Output : [1, 2, 3, 4, 5, 10, 20, 30, 40, 50]



const myAwesomeArray = [1, 2, 3, 4, 5]
// The first argument (0) is the value
// The second argument (1) is the starting index
// The third argument (3) is the ending index
myAwesomeArray.fill(0, 1, 3)
//-------> Output : [1, 0, 0, 4, 5]


const myAwesomeArray = [1, 2, 3, 4, 5]
myAwesomeArray.includes(3)
//-------> Output : true
myAwesomeArray.includes(8)
//-------> Output : false


const myAwesomeArray = ["e", "d", "c", "b", "a"]
myAwesomeArray.reverse()
//-------> Output : ['a', 'b', 'c', 'd', 'e']


const myAwesomeArray = [[1], [2], [3], [4], [5]]
myAwesomeArray.flatMap(arr => arr * 10)
//-------> Output : [10, 20, 30, 40, 50]
// With .flat() and .map()
myAwesomeArray.flat().map(arr => arr * 10)
//-------> Output : [10, 20, 30, 40, 50]


let result = merge([1, 2, 3], [4, 5, 6], [7, 8, 9]);
console.log(result); // выведет [1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre>

	<h2 id="objects">Объекты</h2>
	<pre>
let obj = {'1key': 'a', 'key-2': 'b', key3: 'c'};
let obj = {a: 1, b: 2, c: 3};
let keys = Object.keys(obj);

let obj = {
    year:  2025,
    month: 12,
    day:   31,
};
let {year, month, day} = obj;
	</pre>
	<h2 id="functions">Функции</h2>
	<pre>
function func(num = 0) {
				console.log(num ** 2);
}

	<h2>IIFE</h2>
	<pre>
+function() {
    console.log('!'); // выведет '!'
}();


(function() {
	console.log('!');
})();


(function(str) {
	console.log(str); // выведет '!!!'
})('!!!');


(function() {
	return function() {
		console.log('!');
	};
})()(); // выведет '!'


let result = function() {
	return '!';
}();
console.log(result); // выведет '!'



let sum = 1 + function() {
	return 2;
}();
console.log(sum); // выведет 3


let func = (function() {
	let num = 1;
	
	return function() {
		console.log(num);
		num++;
	}
})();

func(); //выведет 1
func(); //выведет 2
func(); //выведет 3
func(); //выведет 4
func(); //выведет 5
    </pre>

	<h2>Рекурсия</h2>
	<pre>
function func(arr) {
    console.log(arr.shift(), arr);
    
    if (arr.length != 0) {
        func(arr);
    }
}

func([1, 2, 3]);



function getSum(arr) {
	let sum = arr.shift();
	
	if (arr.length !== 0) {
		sum += getSum(arr);
	}
	
	return sum;
}

console.log(getSum([1, 2, 3]));



function func(arr) {
	for (let elem of arr) {
		if (typeof elem == 'object') {
			func(elem);
		} else {
			console.log(elem);
		}
	}
}

func([1, [2, 7, 8], [3, 4, [5, [6, 7]]]]);





function func(arr) {
	let sum = 0;
	
	for (let elem of arr) {
		if (typeof elem == 'object') {
			sum += func(elem);
		} else {
			sum += elem;
		}
	}
	
	return sum;
}

console.log(func([1, [2, 7, 8], [3, 4, [5, [6, 7]]]]));


function func(arr) {
	for (let i = 0; i < arr.length; i++) {
		if (typeof arr[i] == 'object') {
			arr[i] = func(arr[i]);
		} else {
			arr[i] = arr[i] + '!';
		}
	}
	
	return arr;
}

console.log(func([1, [2, 7, 8], [3, 4, [5, 6]]]));
    </pre>

	<h2 id="dom">DOM</h2>
	<pre>
input id="button" type="submit"
let button = document.querySelector('#button');
console.log(button);

div id="parent"
let elem = document.querySelector('#parent input');
console.log(elem);

input id="button" type="submit"
let button = document.querySelector('#button');
button.addEventListener('click', function() {
	console.log('!!!');
});
</pre>
	<h2>Именованный обработчик</h2>
	<pre>
input id="button" type="submit"
let button = document.querySelector('#button');
button.addEventListener('click', func);
function func() {
	console.log('!!!');
}
</pre>
	<h2>Один обработчик ко многим элементам</h2>
	<pre>
button1.addEventListener('click', func);
button2.addEventListener('click', func);

Несколько обработчиков одного события 
button.addEventListener('click', func1);
button.addEventListener('click', func2);
</pre>
	<h2>Работа с текстом элементов</h2>
	<pre>
elem.textContent = '!!!';
</pre>
	<h2>Фокус текстовых полей</h2>
	<pre>
elem.addEventListener('focus', function() {
	console.log(elem.value);
});
</pre>
	<h2>Исключения</h2>
	<pre>
input id="elem" class="aaa bbb"
console.log(elem.className)
</pre>
	<h2>Цепочки методов и свойств</h2>
	<pre>
console.log( document.querySelector('#elem').value )
</pre>
	<h2>Объект this</h2>
	<pre>
input id="elem" value="text"
let elem = document.querySelector('#elem')
function func() {
	console.log(this.value); // выведем содержимое атрибута
}
</pre>
	<h2>Преимущество this</h2>
	<pre>
let elem = document.querySelector('#elem');
elem.addEventListener('click', func);
function func() {
	console.log(elem === this); // выведет true
}
</pre>
	<h2>Получение группы элементов</h2>
	<pre>
p class="www">text1
p class="www">text2
p class="www">text3
let elems = document.querySelectorAll('.www');
for (let elem of elems) {
	console.log(elem.textContent);
}
</pre>
	<h2>Добавление обработчиков в цикле</h2>
	<pre>
let elems = document.querySelectorAll('p');

for (let elem of elems) {
	elem.addEventListener('click', function() {
		console.log(this.textContent);
	});
}
</pre>
	<h2>Отвязывание событий</h2>
	<pre>
let button = document.querySelector('#button');
button.addEventListener('click', func);
function func() {
	console.log('!!!');
	this.removeEventListener('click', func);
}
</pre>
	<h2>Отвязывание анонимных функций</h2>
	<pre>
let elems = document.querySelectorAll('p');
for (let elem of elems) {
	elem.addEventListener('click', function func() {
		console.log(this.textContent);
		this.removeEventListener('click', func); // отвязываем функцию
	});
}
</pre>
	<h2>Атрибуты</h2>
	<pre>
input id="elem" value="abcde"
let elem = document.querySelector('#elem');
let value = elem.getAttribute('value');

input id="elem" value="abcde"
let elem = document.querySelector('#elem');
elem.setAttribute('value', '!!!');

input id="elem" value="abcde"
let elem = document.querySelector('#elem');
elem.removeAttribute('value');

input id="elem" value="abcde"
let elem = document.querySelector('#elem');
console.log(elem.hasAttribute('value'));

div id="elem" data-num="1000"
let elem = document.querySelector('#elem');
console.log(elem.dataset.num); // выведет 1000

div id="elem" data-my-test="1000"
let elem = document.querySelector('#elem');
console.log(elem.dataset.myTest);

div id="elem" data-num="1000" data-my-num="2000"
let elem = document.querySelector('#elem');
console.log(elem.getAttribute('data-num'));    // выведет 1000
console.log(elem.getAttribute('data-my-num')); // выведет 2000

p id="elem" class="www ggg zzz"
let elem = document.querySelector('#elem');
let length = elem.classList.length;
console.log(length);

p id="elem" class="www ggg zzz"
let elem = document.querySelector('#elem');
elem.classList.add('kkk');

elem.classList.remove('ggg');

p id="elem" class="www ggg zzz"
let elem = document.querySelector('#elem');
let contains = elem.classList.contains('ggg');

p id="elem" class="www ggg zzz"
let elem = document.querySelector('#elem');
elem.classList.toggle('zzz');
</pre>
	<h2>Стилизация</h2>
	<pre>
p id="elem"
let elem = document.querySelector('#elem');
elem.style.color = 'red';
elem.style.fontSize = '20px';

p text1
p text2
p text3
let elems = document.querySelectorAll('p');
for (let elem of elems) {
	elem.addEventListener('click', function() {
		this.classList.add('colored'); // добавляем абзацу класс
	});
}

button id="button" click me
div id="elem"
#elem {
	display: none;
	width: 200px;
	height: 200px;
	border: 1px solid green;
}
#elem.active {
	display: block;
}
let button = document.querySelector('#button');
let elem = document.querySelector('#elem');

button.addEventListener('click', function() {
	elem.classList.toggle('active');
});
</pre>
	<h2>Поиск</h2>
	<pre>
Нахождение потомков

div id="parent"
	p 1
	p 2
let parent = document.querySelector('#parent');
let text = parent.firstElementChild.textContent;

let text = parent.lastElementChild.textContent;

div id="parent"
	p 1
	p 2
	p 3
let parent = document.querySelector('#parent');
let elems = parent.children;
for (let elem of elems) {
	console.log(elem.textContent);
}

</pre>
	<h2>Поиск родителей </h2>
	<pre>
div id="parent"
	id="elem"
let elem = document.querySelector('#elem');
let id = elem.parentElement.id;
</pre>
	<h2>Поиск всех родителей </h2>
	<pre>
div class="www" id="parent2"
	div class="ggg" id="parent1"
		p class="zzz" id="child"
		
let elem = document.querySelector('#child');
let parent = elem.closest('.www');
</pre>
	<h2>Поиск соседей</h2>
	<pre>
p sibling
p id="elem" elem

let elem = document.querySelector('#elem');
let text = elem.previousElementSibling.textContent;
let text = elem.nextElementSibling.textContent;
</pre>
	<h2>Поиск элемента по id</h2>
	<pre>
let elem = document.getElementById('elem');
</pre>
	<h2>Поиск элемента по имени тега</h2>
	<pre>
let elems = document.getElementsByTagName('p');
</pre>
	<h2>Поиск элемента по имени класса</h2>
	<pre>
let elems = document.getElementsByClassName('www');
</pre>
	<h2>Узлы</h2>
	<pre>
Перебор узлов циклом
for (let node of elem.childNodes) {
	console.log(node);
}

Все узлы имеют свойство nodeType
Его значение числовое: 1 для элементов, 3 для текстовых узлов, 8 для комментариев

Для всех узлов работает свойство textContent
</pre>
	<h2>Формы</h2>
	<pre>
textarea id="elem" text

input id="elem" disabled
let elem = document.querySelector('#elem');
elem.disabled = false;

input type="checkbox" checked id="elem"
let elem = document.querySelector('#elem');
console.log(elem.checked);
</pre>
	<h2>Чередование атрибутов</h2>
	<pre>
input id="elem" disabled
input id="button" type="submit"

let elem   = document.querySelector('#elem');
let button = document.querySelector('#button');

button.addEventListener('click', function() {
	elem.disabled = !elem.disabled;
});
</pre>
	<h2>Работа с радиокнопками</h2>
	<pre>
input type="radio" name="elem" value="1" checked
input type="radio" name="elem" value="2"
input type="radio" name="elem" value="3"

let radios = document.querySelectorAll('input[type="radio"]');
let button = document.querySelector('#button');

button.addEventListener('click', function() {
	for (let radio of radios) {
		if (radio.checked) {
			console.log(radio.value);
		}
	}
});
	
</pre>
	<h2>Событие change</h2>
	<pre>
input id="elem" value="text"
let elem = document.querySelector('#elem');

elem.addEventListener('change', function() {
	console.log(this.value);
});
</pre>
	<h2>Событие input</h2>
	<pre>
input id="elem"
let elem = document.querySelector('#elem');

elem.addEventListener('input', function() {
	console.log(this.value);
});
</pre>
	<h2>Методы focus и blur</h2>
	<pre>
input id="elem" value="text"
input type="submit" id="button"

let elem   = document.querySelector('#elem');
let button = document.querySelector('#button');

button.addEventListener('click', function() {
	elem.focus();
});
	</pre>
	<h2>Event</h2>
	<pre>
button id="elem" text
elem.addEventListener('click', function(event) {
	console.log(event); // увидим объект с событием
});
	</pre>
	<h2>Координаты события</h2>
	<pre>
clientX clientY pageX pageY
	</pre>
	<h2>Тип события</h2>
	<pre>
elem.addEventListener('click', function(event) {
	console.log(event.type); // выведет 'click'
});
	</pre>
	<h2>Элемент события</h2>
	<pre>
let elem = document.querySelector('#elem');

elem.addEventListener('click', function(event) {
	console.log(event.target); // выведет наш абзац
	console.log(this);         // выведет наш див
});
	</pre>
	<h2>Получение нажатых клавиш </h2>
	<pre>
elem.addEventListener('keypress', function(event) {
	console.log(event.key);
	console.log(event.code);
});
	</pre>
	<h2>Отслеживание клавиш-модификаторов</h2>
	<pre>
if (event.ctrlKey)
if (event.altKey)
if (event.shiftKey)
	</pre>
	<h2>Отмена действия по умолчанию</h2>
	<pre>
event.preventDefault();
	</pre>
	<h2>Всплытие событий</h2>
	<pre>
То есть получается, что когда вы кликаете на самый внутренний блок, событие клика возникает сначала в нем, затем срабатывает в его родителе, в родителе его родителя и так далее, пока не дойдет до самого верха
	</pre>
	<h2>Получение целевого элемента</h2>
	<pre>
let div = document.querySelector('div');

div.addEventListener('click', function(event) {
	if (event.target.matches('div')) {
		console.log('клик именно по диву');
	}
	if (event.target.matches('p')) {
		console.log('клик именно по абзацу');
	}
});
	</pre>
	<h2>Прекращение всплытия</h2>
	<pre>
elem1.addEventListener('click', function() {
	console.log('зеленый');
});
elem2.addEventListener('click', function(event) {
	console.log('голубой');
	event.stopPropagation(); // остановим всплытие
});
	</pre>
	<h2>Несколько обработчиков</h2>
	<pre>
elem1.addEventListener('click', function() {
	console.log('зеленый');
});
elem2.addEventListener('click', function(event) {
	console.log('голубой - первый обработчик');
	event.stopPropagation(); // остановим всплытие
});
elem2.addEventListener('click', function() {
	console.log('голубой - второй обработчик'); // все равно сработает
});
	</pre>
	<h2>Немедленное прекращение всплытия</h2>
	<pre>
elem1.addEventListener('click', function() {
	console.log('зеленый');
});
elem2.addEventListener('click', function(event) {
	console.log('голубой - первый обработчик');
	event.stopImmediatePropagation();     // остановим всплытие
});
elem2.addEventListener('click', function() {
	console.log('голубой - второй обработчик'); // уже не сработает
});
	</pre>
	<h2>Применение прекращения всплытия</h2>
	<pre>
	div id="parent"
		button click me
		div id="block" text
		
при клике на кнопку отменить всплытие, родитель не реагировал на этот клик
	</pre>
	<h2>Погружение событий</h2>
	<pre>
в addEventListener есть третий необязательный параметр. Если он равен true - событие сработает на стадии перехвата, а если false - на стадии всплытия

elem1.addEventListener('click', function() {
	console.log('зеленый - погружение');
}, true);
elem1.addEventListener('click', function() {
	console.log('зеленый - всплытие');
}, false);

elem2.addEventListener('click', function() {
	console.log('голубой - погружение');
}, true);
	</pre>
	<h2>Навешивание обработчиков на новые элементы</h2>
	<pre>
ul
	li item
	li item
	li item
	li item
	li item
	
let button = document.querySelector('button');
let list   = document.querySelector('ul');
let items  = list.querySelectorAll('li');

for (let item of items) {
	item.addEventListener('click', function() {
		this.textContent = this.textContent + '!';
	});
}

function handler() {
	this.textContent = this.textContent + '!';
}

for (let item of items) {
	item.addEventListener('click', handler);
}

button.addEventListener('click', function() {
	let item = document.createElement('li');
	item.textContent = 'item';
	
	item.addEventListener('click', handler);
	
	list.appendChild(item);
});
	</pre>
	<h2>Делегирование событий</h2>
	<pre>
list.addEventListener('click', function(event) {
	event.target.textContent = event.target.textContent + '!';
});
	</pre>
	<h2>Универсальное делегирование</h2>
	<pre>
ul
	li item 
			i italic item
			
	list.addEventListener('click', function(event) {
	let li = event.target.closest('li');
	
	if (li) {
		li.textContent = li.textContent + '!';
	}
});
	</pre>
	<h2>Контекст</h2>
	<pre>
let elem1 = document.querySelector('#elem1');
elem1.addEventListener('blur', func);

let elem2 = document.querySelector('#elem2');
elem2.addEventListener('blur', func);

function func() {
	console.log(this.value); // выведет или 'text1', или 'text2'
}
	</pre>
	<h2>Контекст непривязанной функции</h2>
	<pre>
1) function func() {
	console.log(this); // ссылка на окно window
}

func();


2) "use strict";

function func() {
	console.log(this); // undefined
}

func();

3) console.log(this); // в this ссылка на window
	</pre>
	<h2>Потеря контекста</h2>
	<pre>
"use strict";

let elem = document.querySelector('#elem');
elem.addEventListener('blur', parent);

function parent() {
	console.log(this); // выведет ссылку на наш инпут
	
	function child() {
		console.log(this); // выведет undefined
	}
	child();
}
	</pre>
	<h2>Контекст через переменную</h2>
	<pre>
"use strict";

let elem = document.querySelector('#elem');
elem.addEventListener('blur', parent);

function parent() {
	console.log(this.value); // выведет 'text'
	
	let self = this; // запишем this в любую переменную, например, в self
	
	function child() {
		console.log(self.value); // выведет 'text'
	}
	child();
}
	</pre>
	<h2>Контекст через параметр </h2>
	<pre>
function child(param) {
	// тут будет код
}

let elem = document.querySelector('#elem');
elem.addEventListener('blur', parent);

function parent() {
	child(this); // передаем параметром this
	
	function child(param) {
		console.log(param.value); // выводим value инпута
	}
}
	</pre>
	<h2>Контекст через стрелочную функцию</h2>
	<pre>
let elem = document.querySelector('#elem');
elem.addEventListener('blur', parent);

function parent() {
	console.log(this.value); // выведет 'text'
	
	let child = () => {
		console.log(this.value); // выведет 'text'
	}
	child();
}
	</pre>
	<h2>Привязывание контекста через метод call</h2>
	<pre>
let elem = document.querySelector('#elem');

function func() {
	console.log(this.value); // выведет value инпута
}
func.call(elem);
	</pre>
	<h2>Привязывание контекста через метод apply</h2>
	<pre>
func.apply(elem, [param1, param2]);
	</pre>
	<h2>Привязывание контекста через метод bind</h2>
	<pre>
let elem = document.getElementById('elem');

function func(param1, param2) {
	console.log(this.value + param1 + param2);
}

let newFunc = func.bind(elem);
newFunc('1', '2'); // выведет 'text12'
	</pre>
	<h2>Манипулирование элементами</h2>
	<pre>
let parent = document.querySelector('#parent');

let p = document.createElement('p');
p.textContent = '!';

parent.appendChild(p);
	</pre>
	<h2>Привязывание событий при вставке элементов</h2>
	<pre>
let parent = document.querySelector('#parent');

let p = document.createElement('p');
p.textContent = '!';

p.addEventListener('click', function() {
	console.log(this.textContent); // по клику выведем текст абзаца
});

parent.appendChild(p);
	</pre>
	<h2>Создание элементов в цикле</h2>
	<pre>
let parent = document.querySelector('#parent');

for (let i = 1; i <= 9; i++) {
	let p = document.createElement('p');
	p.textContent = '!';
	
	// Навешиваем обработчик клика:
	p.addEventListener('click', function() {
		console.log(this.textContent);
	});
	
	parent.appendChild(p);
}
	</pre>
	<h2>Удаление элементов</h2>
	<pre>
let elems = document.querySelectorAll('p');

for (let elem of elems) {
	elem.addEventListener('click', function() {
		elem.remove();
	});
}
	</pre>
	<h2>Вставка элементов в начало или в конец</h2>
	<pre>
append prepend
	</pre>
	<h2>Вставка элементов перед элементами</h2>
	<pre>
insertBefore
	</pre>
	<h2>Смежная вставка элементов</h2>
	<pre>
beforeBegin afterEnd afterBegin beforeEndz
	</pre>
	<h2>Смежная вставка тегов</h2>
	<pre>
insertAdjacentHTML
	</pre>
	<h2>Клонирование элементов</h2>
	<pre>
div id="parent"
	div class="elem"
		p первый абзац
		p второй абзац
		
let parent = document.querySelector('#parent');
let elem = parent.querySelector('.elem');

let clone = elem.cloneNode(true);
parent.appendChild(clone);
	</pre>
	<h2>Проверка элементов </h2>
	<pre>
matches contains
	</pre>

	<h2>Typescript</h2>
	<table>
		<tr>
			<td>TypeScript</td>
			<td>отличается от JavaScript возможностью явного статического назначения типов, поддержкой использования полноценных классов (как в традиционных объектно-ориентированных языках), а также поддержкой подключения модулей, что призвано повысить скорость разработки, облегчить читаемость, рефакторинг и повторное использование кода, помочь осуществлять поиск ошибок на этапе разработки и компиляции, и, возможно, ускорить выполнение программ</td>
		</tr>
		<tr>
			<td>Аннотации типов и проверка их согласования на этапе компиляции</td>
			<td>Вывод типов
				Классы
				Интерфейсы
				Перечисляемые типы
				Примесь
				обобщённое программирование
				Модули
				Сокращенный синтаксис «стрелок» для анонимных функций
				Дополнительные параметры и параметры по умолчанию
				Кортежи</td>
		</tr>
		<tr>
			<td>Декораторы</td>
			<td>позволяют добавить к классам и их членам метаданные и тем самым изменить их поведение без изменения их кода</td>
		</tr>
		<tr>
			<td>(type) и интерфейсом (interface)</td>
			<td>с type у нас может быть объединение нескольких других type</td>
		</tr>
		<tr>
			<td>JSX</td>
			<td>встраиваемый XML-подобный синтаксис, который позволяет создавать HTML</td>
		</tr>
		<tr>
			<td>директивы с тремя наклонными чертами (Triple-Slash Directives), их типы?</td>
			<td>однострочными комментариями, включающими в себя единственный тэг XM /// reference path="..." /</td>
		</tr>
		<tr>
			<td>Внешнее объявление переменной</td>
			<td>механизм, который позволяет сообщать компилятору TypeScript о том, что некий исходный код существует где-то за пределами текущего файла</td>
		</tr>
		<tr>
			<td>Разница между абстрактным классом (abstract class) и интерфейсом (interface)?</td>
			<td>Абстрактный класс — это класс, у которого не реализован один или больше методов (некоторые языки требуют такие методы помечать специальными ключевыми словами). Интерфейс — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных класса</td>
		</tr>
		<tr>
			<td>Какие элементы ООП поддерживаются в TypeScript?</td>
			<td>Number.
				String.
				Boolean.
				Array.
				Enum.
				Any.
				Void.</td>
		</tr>
		<tr>
			<td>Модификаторы доступа в TypeScript?</td>
			<td>public, protected и private.</td>
		</tr>
		<tr>
			<td>внутренним (Internal Module)</td>
			<td>Внутренние модули появились в ранней версии Typescript. Их использовали для того, чтобы логически сгруппировать классы, интерфейсы, функции в один элемент и экспортировать в другой модуль namespace TutorialPoint {
				export function add(x, y) { console.log(x + y);}
				}</td>
		</tr>
		<tr>
			<td>внешним модулями (External Module)</td>
			<td>Внешние модули в TypeScript были созданы для того, чтобы задавать и загружать зависимости между множественными внешними js-файлами
				export interface SomeInterface {
				//объявление кода
				}</td>
		</tr>
		<tr>
			<td>Как TypeScript поддерживает необязательные и дефолтные параметры в функции?</td>
			<td>last?: string</td>
		</tr>
		<tr>
			<td>enum</td>
			<td>конструкция представляющая из себя список именованных констант</td>
		</tr>
		<tr>
			<td>noImplicitAny</td>
			<td>Это первый флаг, который необходимо активировать в начале работы над проектом с TypeScript.</td>
		</tr>
		<tr>
			<td>Разница между типами “Объединение” (|) и “Пересечение” (&#38;)?</td>
			<td>Объединение (Union) - это мощный механизм, позволяющий создавать из множества существующих типов логическое условие let v1: T1 | T2 | T3;</td>
		</tr>
		<tr>
			<td>Пересечение</td>
			<td>Пересечение (Intersection) — ещё один мощный механизм TypeScript, который позволяет рассматривать множество типов данных как единое целое. let name: A &#38; B &#38; C; // значение должно принадлежать ко всем типам одновременно</td>
		</tr>
		<tr>
			<td>Дженерики</td>
			<td>обобщенные типы. Они нужны для описания похожих, но отличающихся какими-то характеристиками типов</td>
		</tr>
		<tr>
			<td>Что такое .map файл, как и зачем его использовать?</td>
			<td>это файлы игр, сохраненные в текстовом формате</td>
		</tr>
		<tr>
			<td>Можно ли использовать TypeScript в серверной разработке?</td>
			<td>после компиляции программу на TypeScript можно выполнять в любом современном браузере или использовать совместно с серверной платформой Node</td>
		</tr>
		<tr>
			<td>Для чего в TypeScript используют ключевое слово declare?</td>
			<td>С помощью ключевого слова declare в программу на TS подключается определение глобальной переменной</td>
		</tr>
		<tr>
			<td>Разница между типами void, never и unknown?</td>
			<td>Тип данных Void можно назвать полной противоположностью типа any, так как этот тип означает отсутствие конкретного типа. Примитивный типа данных Never служит для указания того, что какие-либо операции никогда не будут выполнены. Все типы совместимы с типом unknown, в то время как сам тип unknown совместим только с самим собой и типом any</td>
		</tr>
	</table>

	<h2>VUE</h2>
	<table>
		<tr>
			<td>VUE</td>
			<td>прогрессивный фреймворк</td>
		</tr>
		<tr>
			<td>особенности Vue.js?</td>
			<td>Vue подходит для небольших проектов, которым необходимо добавить немного реактивности, представить форму с помощью AJAX, отобразить значения при вводе данных пользователем, авторизация или другие аналогичные задачи.</td>
		</tr>
		<tr>
			<td>Перечислите преимущества Vue.js?</td>
			<td>
				<ol>
					<li>достаточно быстрая разработка</li>
					<li>небольшой вес фреймворка</li>
					<li>хороша документация</li>
					<li>большое сообщество разработчиков</li>
					<li>быстрое взаимодействие с виртуальным DOM</li>
					<li>подключение плагинов и создание своих плагинов</li>
					<li>компонентная разработка приложения</li>
					<li>реализует современные подходы к разработке</li>
				</ol>
			</td>
		</tr>
		<tr>
			<td>хуки жизненного цикла</td>
			<td>
				<ol>
					<li>beforeCreate</li>
					<li>created</li>
					<li>beforeMount</li>
					<li>mounted</li>
					<li>beforeUpdate</li>
					<li>updated</li>
					<li>beforeUnmount</li>
					<li>unmounted</li>
					<li>errorCaptured</li>
					<li>renderTracked</li>
					<li>renderTriggered</li>
					<li>activated</li>
					<li>deactivated</li>
				</ol>
			</td>
		</tr>
		<tr>
			<td>жизненный цикл компонента</td>
			<td>
				<ol>
					<li>конструктор new Vue()</li>
					<li>beforeCreate</li>
					<li>инициализация объекта Vue</li>
					<li>created</li>
					<li>компиляция шаблона</li>
					<li>beforeMount</li>
					<li>Элемент html, к которому прикреплен объект Vue, заменяется скомпилированным шаблоном</li>
					<li>mounted</li>
					<li>beforeUpdate</li>
					<li>updated</li>
					<li>beforeDestroy</li>
					<li>destroyed</li>
				</ol>
			</td>
		</tr>
		<tr>
			<td>Что такое условные директивы (conditional directives)?</td>
			<td>Директива v-if позволяет по условию изменять структуру DOM на веб-странице</td>
		</tr>
		<tr>
			<td>Разница между директивами v-show и v-if?</td>
			<td>v-if выводит элементы в DOM только в случае, если выражение проходит, а v-show отображает все элементы</td>
		</tr>
		<tr>
			<td>Какие модификаторы событий предоставляет Vue.js?</td>
			<td>stop.
				prevent.
				capture.
				self.
				once.
				passive.</td>
		</tr>
		<tr>
			<td>Какие модификаторы кнопок предоставляет Vue.js?</td>
			<td>enter.
				tab.
				delete (ловит как «Delete», так и «Backspace»)
				esc.
				space.
				up.
				down.
				left.</td>
		</tr>
		<tr>
			<td>Какие модификаторы кнопок мыши предоставляет Vue.js?</td>
			<td>ctrl.
				alt.
				shift.
				meta.</td>
		</tr>
		<tr>
			<td>Что такое пропсы? Типы пропсов?</td>
			<td>кастомный атрибут, который вы можете зарегистрировать в любом компоненте. Вы определяете данные в родительском компоненте и присваиваете им определенное значение</td>
		</tr>
		<tr>
			<td>Разница между локальной и глобальной регистрацией компонента?</td>
			<td>лобальные компоненты доступны для любого объекта Vue на веб-странице. Локальные компоненты доступны только в рамках определенных объектов Vue</td>
		</tr>
		<tr>
			<td>Что такое миксины Vue.js?</td>
			<td>гибкий инструмент повторного использования кода в компонентах Vue</td>
		</tr>
		<tr>
			<td>Что такое Vue CLI?</td>
			<td>npm-пакет, устанавливаемый глобально и предоставляющий команду vue в терминале</td>
		</tr>
		<tr>
			<td>Что такое Vuex?</td>
			<td>паттерн управления состоянием + библиотека для приложений на Vue.js. централизованным хранилищем данных для всех компонентов приложения с правилами, гарантирующими, что состояние может быть изменено только предсказуемым образом.</td>
		</tr>
		<tr>
			<td>Что общего у React и Vue.js?</td>
			<td>Они оба имеют компонентно-ориентированный подход, который позволяет разбивать приложение на меньшие, легко повторно используемые и тестируемые части.</td>
		</tr>
		<tr>
			<td>Разница между React и Vue.js?</td>
			<td>React, разработанный Facebook, используется для создания компонентно-ориентированных приложений. Vue, написанный Эваном Яо, используется для создания простых и гибких приложений.</td>
		</tr>
		<tr>
			<td>Разница между Angular и Vue.js?</td>
			<td>Angular - это фреймворк, который идеально подходит для разработки крупногабаритных проектов, а Vue. js - это прогрессивный фреймворк, который идеально подходит для легких одностраничных проектов.</td>
		</tr>
		<tr>
			<td>Что такое Vue Router? Назовите его особенности?</td>
			<td>официальная библиотека маршрутизации для Vue. js</td>
		</tr>
		<tr>
			<td>Что такое фильтры? Как создать цепочку фильтров?</td>
			<td>Они находят своё применение в двух местах: в mustache-интерполяциях и в выражениях v-bind (последнее поддерживается в 2.1.0+). Фильтры добавляются в конце выражения JavaScript и отделяются вертикальной чертой: v-bind:id="rawId | formatId"</td>
		</tr>
		<tr>
			<td>Перечислите варианты коммуникации компонентов во Vue.js?</td>
			<td>от родительского элемента к дочернему информация передается через пропсы, а обратно — вызываются события.</td>
		</tr>
		<tr>
			<td>Какие модификаторы поддерживаются в модели (v-model)?</td>
			<td>КАРДИНАЛЬНОЕ ИЗМЕНЕНИЕ: При использовании на компонентах v-model поменялись входной параметр и имя события:
				входной параметр: value -> modelValue;
				событие: input -> update:modelValue;
				КАРДИНАЛЬНОЕ ИЗМЕНЕНИЕ: Модификатор .sync для v-bind и опция компонента model были удалены и заменяются возможностью указать аргумент v-model;
				НОВОЕ: Теперь возможны несколько привязок v-model на одном компоненте;
				НОВОЕ: Добавлена возможность создавать собственные модификаторы для v-model.</td>
		</tr>
		<tr>
			<td>Что такое плагины? Какие возможности дают плагины для Vue.js?</td>
			<td>самодостаточная единица кода, которая добавляет во Vue функциональность глобального уровня</td>
		</tr>
		<tr>
			<td>Что такое слот (slot) во Vue.js?</td>
			<td>Слоты могут содержать любой код шаблона, в том числе HTML</td>
		</tr>
		<tr>
			<td>Какие хуки предоставляют директивы?</td>
			<td>bind - вызывается при привязке директивы к элементу. Вызывается только один раз.
				inserted - вызывается после того, как элемент вставлен в родительский DOM.
				update - вызывается при обновлениях элемента, но дочерние ещё не будут обновлены.
				componentUpdated - вызывается после обновления компонента и его потомков.
				unbind - вызывается после удаления директивы. Также вызывается только один раз.</td>
		</tr>
		<tr>
			<td>Что такое vue-loader?</td>
			<td>Позволяет использовать разнообразные загрузчики webpack для разных секций компонента Vue, например Sass для style и Pug для template</td>
		</tr>
		<tr>
			<td>Что такое рендер-функция (render function)? Преимущества рендер-функции?</td>
			<td>возникает необходимость в использовании всех алгоритмических возможностей JavaScript. В таких случаях можно применить render-функции — более низкоуровневую альтернативу шаблонам.</td>
		</tr>
		<tr>
			<td>Что такое динамические (keep-alive) компоненты?</td>
			<td>При выборе и переключении, выбранный таб останется прежним</td>
		</tr>
		<tr>
			<td>Асинхронные компоненты</td>
			<td>В больших приложениях может потребоваться разделять приложение на меньшие части и загружать компоненты с сервера только когда они необходимы. Для реализации подобного Vue предоставляет метод defineAsyncComponent</td>
		</tr>
	</table>

</body>

</html>
