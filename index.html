<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Title</title>
	<link rel="stylesheet" href="main.css">
</head>

<body>
	<h1>Вопросы к собеседованию</h1>

	<h2>Web Technologies (общие вопросы по веб-разработке)</h2>
	<table>
		<tr>
			<td>Серверный рендеринг</td>
			<td>генерирует HTML на сервере и отдаёт пользователю готовый исходный код со всем DOM</td>
		</tr>
		<tr>
			<td>Клиентский</td>
			<td>клиенту отдает JS-бандл</td>
		</tr>
		<tr>
			<td>Прогрессивный</td>
			<td>можно один раз создать себе сайт и выложить его на сервер, где есть только Nginx</td>
		</tr>
		<tr>
			<td>PWA</td>
			<td>мобильное приложение в браузере</td>
		</tr>
		<tr>
			<td>Сетевая модель OSI</td>
			<td>Посредством данной модели различные сетевые устройства могут взаимодействовать друг с другом</td>
		</tr>
		<tr>
			<td>REST</td>
			<td>способ создания API с помощью протокола HTTP</td>
		</tr>
		<tr>
			<td>RESTful API</td>
			<td>интерфейс,используемые двумя компьютерными системами для безопасного обмена информацией через Интернет</td>
		</tr>
		<tr>
			<td>History API</td>
			<td>доступ к управлению историей браузера в рамках текущей сессии</td>
		</tr>
		<tr>
			<td>Local Storage</td>
			<td>Хранит данные бессрочно.
				Очищается только с помощью JavaScript или очистки кэша браузера.
				Хранит данные объёмом до 5 МБ, это самый большой объём из трёх вариантов хранилища.
				Не поддерживается старыми браузерами, например, IE 7 и ниже.
				Работает по правилу ограничения домена (same origin policy). То есть сохранённые данные доступны только для одного источника</td>
		</tr>
		<tr>
			<td>Session Storage</td>
			<td>Хранит данные, пока продолжается текущая сессия. Когда пользователь закрывает браузер, данные становятся недоступными.
				Используется контекст браузера верхнего уровня, поэтому каждая вкладка браузера хранит уникальные данные.
				Объём данных больше чем в Cookie.
				Не поддерживается старыми браузерами, например, IE 7 и ниже.</td>
		</tr>
		<tr>
			<td>Cookie</td>
			<td>Хранит данные, которые можно передавать на сервер через заголовки.
				Локальное и сессионное хранилище доступны только на клиентской стороне.
				Срок хранения устанавливается при создании cookie.
				Объём данных не превышает 4 Кбайт.
				Cookie могут быть защищёнными, в этом случае их содержимое нельзя получить на стороне клиента. Это важно для аутентификации при хранении пользовательских токенов.</td>
		</tr>
		<tr>
			<td>Core Web Vitals</td>
			<td>группа новых факторов ранжирования Google, которые запускаются в мае 2021 года. В эту группу входят 3 параметра: LCP (Largest Contentful Paint) — скорость загрузки основного контента. Основной контент — это самый большой элемент на странице: текст, видео</td>
		</tr>
		<tr>
			<td>метрика Core Web Vitals</td>
			<td>LCP (Largest Contentful Paint) — скорость загрузки основного контента веб-страницы. Основной контент — это самый большой элемент на странице: текст, видео, картинка. Гугл сравнивает разницу между загрузкой основного контента и остальных элементов веб-страницы.

				FID (First Input Delay) — время ожидания до начала взаимодействия пользователя с сайтом. Чем дольше пользователю приходится ждать момента, когда можно начать взаимодействовать со страницей (скролить, кликать по ссылкам, наживать на кнопки) тем ниже лидогенерация и выше показатель отказов.

				CLS (Cumulative Layout Shift) — устойчивость верстки и элементов, которые мешают пользователю взаимодействовать с сайтом. Если в процессе загрузки элементы, особенно кликабельные, смещаются по экрану, пользователь может нажать не на ту кнопку, что не понравится ни пользователю, ни Google.</td>
		</tr>
		<tr>
			<td>PRPL</td>
			<td>это паттерн, рекомендуемый командой разработчиков Chrome для организации поэтапной загрузки кода. Он рассчитан на то, чтобы приложения, использующие его, как можно быстрее становились бы интерактивными на дешёвых устройствах и в медленных сетях. Паттерн PRPL поощряет предварительную загрузку минимального объёма JS-кода, необходимого для того, чтобы со страницей можно было бы работать. Затем ресурсы загружаются с использованием методик ленивой загрузки. Если нужно — можно воспользоваться сервис-воркером для предварительного кэширования JavaScript-ресурсов, необходимых для будущих взаимодействий с сайтом.</td>
		</tr>
	</table>

	<h2 class="accordion">Web API (вопросы из веб API)</h2>
	<table>
		<tr>
			<td>HTTP-запрос</td>
			<td>для передачи гипертекстовых документов, то есть документов, которые могут содержать ссылки, позволяющие организовать переход к другим документам</td>
		</tr>
		<tr>
			<td>Какие методы может иметь HTTP-запрос?</td>
			<td>OPTIONS.
				GET.
				HEAD.
				POST.
				PUT.
				PATCH.
				DELETE.
				TRACE.</td>
		</tr>
		<tr>
			<td>HTTP/2</td>
			<td>двоичный уровень кадрирования</td>
		</tr>
		<tr>
			<td>мультиплексирование в HTTP/2</td>
			<td>множество запросов в рамках одного TCP-соединения</td>
		</tr>
		<tr>
			<td>трехстороннее рукопожатие Triple handshake</td>
			<td>соединения между локальным хостом/клиентом и сервером</td>
		</tr>
		<tr>
			<td>PUT запрос</td>
			<td>должен быть задан уникальный ID указанного ресурса</td>
		</tr>
		<tr>
			<td>TCP и UDP</td>
			<td>TCP предполагает потоковую передачу данных, границы фрагментов данных не обозначены. UDP использует метод датаграмм, когда получатель проверяет целостность пакетов лишь при получении сообщения</td>
		</tr>
		<tr>
			<td>WebSocket</td>
			<td>двунаправленный протокол связи между клиентом (браузером) и сервером, позволяющий обмениваться сообщениями в режиме реального времени.</td>
		</tr>
		<tr>
			<td>Long Polling</td>
			<td>процесс, при котором соединение между сервером и клиентом не разрывается длительный период, а при разрыве повторно создается.</td>
		</tr>
		<tr>
			<td>Server Sent Events</td>
			<td>Идеально подойдет для динамически изменяемой информации в приложении. Например, различная real-time статистика, текстовые трансляции матчей и так далее</td>
		</tr>
		<tr>
			<td>JSONP</td>
			<td>JSONP работает путем внедрения тега script на страницу, который загружает файл JSON с сервера и обрабатывает его с помощью пользовательской функции.</td>
		</tr>
		<tr>
			<td>IndexedDB</td>
			<td>IndexedDB — это механизм, который позволяет хранить большие объемы данных на клиентской стороне, где браузер обладает доступом к файловой системе пользователя</td>
		</tr>
		<tr>
			<td>Service Workers</td>
			<td>скрипт, который работает в фоновом режиме, независимо от веб-страницы</td>
		</tr>
		<tr>
			<td>Web Workers</td>
			<td>ресурсоёмкие вычисления могут выполняться в отдельном потоке</td>
		</tr>
		<tr>
			<td>SSL/TLS</td>
			<td>цифровой объект, который позволяет системам проверять личность и впоследствии устанавливать зашифрованное сетевое соединение с другой системой</td>
		</tr>
		<tr>
			<td>CDN</td>
			<td>это географически распределённая сетевая инфраструктура</td>
		</tr>
		<tr>
			<td>IP-адрес</td>
			<td>это уникальный адрес, идентифицирующий устройство в интернете или локальной сети</td>
		</tr>
		<tr>
			<td>Доменные имена, Хостинг</td>
			<td>который вводят пользователи, чтобы зайти на сайт, место размещения веб-сайтов на серверах.</td>
		</tr>
		<tr>
			<td>URL</td>
			<td>Uniform Resource Locator (унифицированный определитель местонахождения ресурса)</td>
		</tr>
		<tr>
			<td>URN</td>
			<td>Unifrorm Resource Name (унифицированное имя ресурса)</td>
		</tr>
		<tr>
			<td>Идентификация</td>
			<td>процедура, в результате выполнения которой для субъекта идентификации выявляется его идентификатор, однозначно определяющий этого субъекта в информационной системе.</td>
		</tr>
		<tr>
			<td>Аутентификация</td>
			<td>процедура проверки подлинности, например проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных.</td>
		</tr>
		<tr>
			<td>Авторизация</td>
			<td>предоставление определенному лицу или группе лиц прав на выполнение определенных действий.</td>
		</tr>
		<tr>
			<td>Виды аутентификации</td>
			<td>электронной подписи,по паролям,SMS,Биометрическая аутентификация,географическое местоположение,Многофакторная аутентификация</td>
		</tr>
		<tr>
			<td>(Secure) и HttpOnly cookies</td>
			<td>Атрибут secure и флаг httpOnly работают вместе, чтобы гарантировать, что браузер может ограничить доступ к защищенным данным cookie из вредоносных скриптов, которые могли заразить браузер или сеть.</td>
		</tr>
		<tr>
			<td>Content Security Policy</td>
			<td>дополнительный уровень безопасности, позволяющий распознавать и устранять определённые типы атак, таких как Cross Site Scripting</td>
		</tr>
		<tr>
			<td>Cross-Origin Resource Sharing</td>
			<td>использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент.</td>
		</tr>
		<tr>
			<td>XSS</td>
			<td>тип атаки на веб-системы, заключающийся во внедрении в выдаваемую веб-системой страницу вредоносного кода</td>
		</tr>
		<tr>
			<td>Методы повышения безопасности веб-приложений</td>
			<td>проверка данных на соответствие стандартам протоколов;
				контроль трафика на основе нейронных сетей;
				сигнатурный анализ;
				защита от SQL-инъекций;
				протекция от межсетевого скриптинга (XSS);
				контроль доступа к конфиденциальным данным.</td>
		</tr>
		<tr>
			<td>OWASP</td>
			<td>это стандартный информационный документ для разработчиков и безопасности веб-приложений</td>
		</tr>
		<tr>
			<td>композиция и наследование</td>
			<td>композиция даёт возможность переиспользовать код без расширения существующего класса, как это происходит в случае с наследованием</td>
		</tr>
		<tr>
			<td>Шаблон проектирования</td>
			<td>(паттерн, от англ. design pattern) — повторяемая архитектурная конструкция в сфере проектирования программного обеспечения, предлагающая решение проблемы проектирования в рамках некоторого часто возникающего контекста.</td>
		</tr>
		<tr>
			<td>Полиморфизм</td>
			<td>способность функции работать с данными разных типов</td>
		</tr>
		<tr>
			<td>Абстрактные классы в объектно-ориентированном программировании</td>
			<td>базовые классы, которые можно наследовать, но нельзя реализовывать. То есть на их основе нельзя создать объект</td>
		</tr>
		<tr>
			<td>JavaScript каждый объект имеет объект-прототип</td>
			<td>В свою очередь этот объект-прототип может содержать в себе другой прототип и наследовать свойства уже от него. В итоге объект-экземпляр получает доступ ко всей цепочке прототипов и их свойствам и методам.</td>
		</tr>
		<tr>
			<td>Реактивное программирование</td>
			<td>парадигма программирования, ориентированная на потоки данных и распространение изменений. Это означает, что должна существовать возможность легко выражать статические и динамические потоки данных, а также то, что нижележащая модель исполнения должна автоматически распространять изменения благодаря потоку данных.</td>
		</tr>
		<tr>
			<td>Inversion of Control</td>
			<td>каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других компонентов.</td>
		</tr>
	</table>

	<h2>OOP & FP (вопросы из объектно-ориентированного и функционального программирования)</h2>
	<table>
		<tr>
			<td>ООП</td>
			<td>
				<ul>
					<li>Инкапсулируйте все, что может изменяться;</li>
					<li>Уделяйте больше внимания интерфейсам, а не их реализациям;</li>
					<li>Каждый класс в вашем приложении должен иметь только одно назначение;</li>
					<li>Классы — это их поведение и функциональность.</li>
				</ul>
			</td>
		</tr>
		<tr>
			<td>Абстракция</td>
			<td>отделение концепции от ее экземпляра</td>
		</tr>
		<tr>
			<td>Полиморфизм</td>
			<td>реализация задач одной и той же идеи разными способами</td>
		</tr>
		<tr>
			<td>Наследование</td>
			<td>способность объекта или класса базироваться на другом объекте или классе</td>
		</tr>
		<tr>
			<td>Инкапсуляция</td>
			<td>размещение одного объекта или класса внутри другого для разграничения доступа к ним</td>
		</tr>
		<tr>
			<td>Делегация</td>
			<td>перепоручение задачи от внешнего объекта внутреннему</td>
		</tr>
		<tr>
			<td>Композиция</td>
			<td>включение объектом-контейнером объекта-содержимого и управление его поведением; последний не может существовать вне первого
			</td>
		</tr>
		<tr>
			<td>Агрегация</td>
			<td>включение объектом-контейнером ссылки на объект-содержимое; при уничтожении первого последний продолжает существование
			</td>
		</tr>
		<tr>
			<td>DRY</td>
			<td>Не повторяйся</td>
		</tr>
		<tr>
			<td>Принцип единственной обязанности</td>
			<td>Для каждого класса должно быть определено единственное назначение</td>
		</tr>
		<tr>
			<td>Принцип открытости/закрытости</td>
			<td>Программные сущности должны быть открыты для расширения, но закрыты для изменений</td>
		</tr>
		<tr>
			<td>Принцип подстановки Барбары Лисков</td>
			<td>Методы, использующие некий тип, должны иметь возможность использовать его подтипы, не зная об этом</td>
		</tr>
		<tr>
			<td>Принцип разделения интерфейсов</td>
			<td> Предпочтительнее разделять интерфейсы на более мелкие тематические, чтобы реализующие их классы не были вынуждены определять методы, которые непосредственно в них не используются</td>
		</tr>
		<tr>
			<td>Принцип инверсии зависимостей</td>
			<td>Система должна конструироваться на основе абстракций «сверху вниз»: не абстракции должны формироваться на основе деталей, а детали должны формироваться на основе абстракций</td>
		</tr>
		<tr>
			<td>SOLID</td>
			<td>принципы объектно‑ориентированного программирования</td>
		</tr>
		<tr>
			<td>Классовое наследование</td>
			<td>экземпляры наследуются от классов, создаются подклассовые отношения</td>
		</tr>
		<tr>
			<td>лучше использовать прототипное наследование</td>
			<td>Делегирование (цепочка прототипов)
				Конкатенация (миксины, Object.assign())
				Функциональное наследование (не путать с функциональным программированием. Функция используется для создания замыкания для private/инкапсуляции)</td>
		</tr>
		<tr>
			<td>Двусторонняя связь данных</td>
			<td>поля интерфейса связаны с моделью данных динамически, то есть при изменении полей интерфейса меняется модель, и наоборот</td>
		</tr>
		<tr>
			<td>Функциональное программирование</td>
			<td>подразумевает вычисление математических функций, избегая общих состояний и изменяемых данных</td>
		</tr>
		<tr>
			<td>MVC</td>
			<td>способ организации кода, который предполагает выделение блоков, отвечающих за решение разных задач</td>
		</tr>
		<tr>
			<td>MVVM</td>
			<td>паттерн разработки, позволяющий разделить приложение на три функциональные части:

				Model — основная логика программы (работа с данными, вычисления, запросы и так далее)
				View — вид или представление (пользовательский интерфейс)
				ViewModel — модель представления, которая служит прослойкой между View и Mode</td>
		</tr>
		<tr>
			<td>Minimal Viable Product</td>
			<td>тестовая версия товара, услуги или сервиса с минимальным набором функций (иногда даже одной), которая несет ценность для конечного потребителя</td>
		</tr>
		<tr>
			<td>Метод</td>
			<td>функция или процедура, которая принадлежит классу или экземпляру класса</td>
		</tr>
		<tr>
			<td>Каррирование</td>
			<td>f(a, b, c), а как f(a)(b)(c)</td>
		</tr>
		<tr>
			<td>Монолитная архитектура</td>
			<td>отдельная большая вычислительная сеть с единой базой кода, в которой объединены все бизнес-задачи</td>
		</tr>
		<tr>
			<td>Микросервисная архитектура</td>
			<td>метод организации архитектуры, основанный на ряде независимо развертываемых служб</td>
		</tr>
		<tr>
			<td>дескрипторы</td>
			<td>пары ключ-значение, которые описывают поведение свойства объекта при выполнении операций над ним (например, чтения или записи)</td>
		</tr>
		<tr>
			<td>Геттеры и сеттеры</td>
			<td>аксессоры или вычисляемые свойства. Это методы, имитирующие поля, но позволяющие читать и записывать данные. Геттеры используются для получения данных, сеттеры — для их изменения</td>
		</tr>
	</table>

	<h2>HTML (вопросы по языку гипертекстовой разметки)</h2>
	<table>
		<tr>
			<td>Глобальные атрибуты</td>
			<td>
				<ol>
					<li>class</li>
					<li>data-*</li>
					<li>dir (en-US)</li>
					<li>hidden (en-US)</li>
					<li>id</li>
					<li>lang</li>
					<li>style</li>
					<li>tabindex</li>
					<li>title (en-US)</li>
					<li>translate (en-US)</li>
				</ol>
			</td>
		</tr>
		<tr>
			<td>категории контента</td>
			<td>
				<ol>
					<li>Метаданные</li>
					<li>Основной поток</li>
					<li>Секционный контент</li>
					<li>Заголовочный контент</li>
					<li>Фразовый контент</li>
					<li>Встроенный контент</li>
					<li>Интерактивный контент</li>
					<li>Явный контент</li>
					<li>Контент форм</li>
					<li></li>
				</ol>
			</td>
		</tr>
		<tr>
			<td>Метатеги</td>
			<td>элементы (html-теги) веб страницы, используемые для передачи структурированных метаданных, как правило, размещаются в разделе head (заголовок, ключевые слова, описание страницы и другие служебные данные)</td>
		</tr>
		<tr>
			<td>viewport</td>
			<td>сообщает браузеру о том, как именно обрабатывать размеры страницы, и изменять её масштаб</td>
		</tr>
		<tr>
			<td>picture</td>
			<td>контейнером для одного или более элементов source и одного элемента img для обеспечения оптимальной версии изображения для различных размеров экрана</td>
		</tr>
		<tr>
			<td>srcset</td>
			<td>содержатся URL изображений и сведения об их ширине</td>
		</tr>
		<tr>
			<td>decoding</td>
			<td>интерфейса HTMLImageElement предназначено для указания браузеру, как он должен декодировать изображение</td>
		</tr>
		<tr>
			<td>enterkeyhint</td>
			<td>предоставляет браузеру подсказку об ожидаемом действии, когда пользователь нажимает клавишу Enter при взаимодействии с элементом ввода</td>
		</tr>
		<tr>
			<td>pattern</td>
			<td>определяет регулярное выражение, по которому проверяются вводимые данные</td>
		</tr>
	</table>

	<h2>Основы</h2>
	<table>
		<tr>
			<td>Типы данных</td>
			<td>string, number, undefined, null, bigint, object, symbol, boolean</td>
		</tr>
		<tr>
			<td>Взаимодействие с пользователем</td>
			<td>alert, prompt, confirm</td>
		</tr>
		<tr>
			<td>Условия</td>
			<td>if else, switch, ?::</td>
		</tr>
		<tr>
			<td>Логические операторы</td>
			<td>|| && !! !</td>
		</tr>
		<tr>
			<td>Циклы</td>
			<td>for, while, do while, for in, for of</td>
		</tr>
		<tr>
			<td>Symbol</td>
			<td>для создания уникальных идентификаторов</td>
		</tr>
		<tr>
			<td>== и ===</td>
			<td>Оператор строгого равенства === не приводит к неявному преобразованию типов. </td>
		</tr>
		<tr>
			<td>Типы таймеров</td>
			<td>одни выполняются только один раз, а другие постоянно через промежуток времени</td>
		</tr>
		<tr>
			<td>.call(), .apply() и bind()</td>
			<td>call - вызов функции с подменой контекста - this внутри функции apply - вызов функции с переменным количеством аргументов и с подменой контекста.bind </td>
		</tr>
		<tr>
			<td>методы используются в регулярных выражениях</td>
			<td>RegExp и String str.match(regexp) str.matchAll(regexp) str.split(regexp|substr, limit) str.search(regexp) str.replace(str|regexp, str|func)</td>
		</tr>
		<tr>
			<td>polyfill</td>
			<td>Полифил — это фрагмент кода (в сети — обычно JavaScript), который позволяет использовать современную функциональность в более старых браузерах, которые не поддерживают ее по умолчанию</td>
		</tr>
		<tr>
			<td>Типы операторов в JavaScript</td>
			<td>Типы операторов
				Операторы присваивания
				Арифметические операторы
				Операторы сравнения
				Логические операторы
				Побитовые операторы
				Строковые операторы
				Другие операторы</td>
		</tr>
		<tr>
			<td>сборщик мусора</td>
			<td>Объекты сохраняются в памяти, пока они достижимы.
				Если на объект есть ссылка – вовсе не факт, что он является достижимым</td>
		</tr>
		<tr>
			<td>утечки памяти</td>
			<td>когда браузер по какой-то причине не может освободить память от недостижимых объектов</td>
		</tr>
		<tr>
			<td>контекст выполнения</td>
			<td>Каждый раз, когда запускаем функцию, мы добавляем скобки {}, а затем выполняем или запускаем её</td>
		</tr>
		<tr>
			<td>Разница между примитивом и объектом</td>
			<td>у примитивов нет своих методов, но у всех них, за исключением null и undefined , есть объектные аналоги, который оборачивает значение примитивного типа и позволяют производить над ними различные преобразования</td>
		</tr>
		<tr>
			<td>DOM</td>
			<td>HTML/XML документы представлены в браузере в виде DOM-дерева</td>
		</tr>
		<tr>
			<td>Методы поиска элементов</td>
			<td>getElement*, querySelector*</td>
		</tr>
		<tr>
			<td>Свойства для перемещения по DOM-дереву</td>
			<td>parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling.
				Только для узлов-элементов: parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling</td>
		</tr>
		<tr>
			<td>BOM</td>
			<td>oбъектная модель браузера (BOM от англ. Browser Object Model) позволяет JavaScript "общаться" с браузером</td>
		</tr>
		<tr>
			<td>Виды событий</td>
			<td>события мыши (Mouse Events), события клавиатуры (Keyboard Events), события объектов и фреймов (Frame/Object Events), события формы и элементов управления (Form Events), события перетаскивания (Drag Events), события анимации (Animation Events), события буфера обмена (Clipboard Events), события мультимедиа (Media Events), события трансформации (Transition Events), события, посылаемые сервером (Server-Sent Events), события касания (Touch Events), события печати (Print Events), разные события (Misc Events)</td>
		</tr>
		<tr>
			<td>Как добавить обработчик события</td>
			<td>addEventListener принимает 2 аргумента: Тип события (мы будем "слушать" событие "click"). Так называемую колбэк (callback) функцию</td>
		</tr>
		<tr>
			<td>распространение события</td>
			<td>движение события от корневого элемента к целевому и обратно</td>
		</tr>
		<tr>
			<td>делегирование событий</td>
			<td>добавлении обработчиков событий к родительскому элементу, а не к дочерним элементам</td>
		</tr>
		<tr>
			<td>media выражения</td>
			<td>@media (min-width: 768px) window.matchMedia('(min-width: 768px)')</td>
		</tr>
		<tr>
			<td>HTMLCollection и NodeList</td>
			<td>NodeList может хранить любые типы узлов, а HTMLCollection — только узлы HTML </td>
		</tr>
		<tr>
			<td>динамически добавить элемент</td>
			<td>document.createTextNode(text) document.body.append(div) elem.insertAdjacentHTML(where, html) node.remove() elem.cloneNode(true) DocumentFragment</td>
		</tr>
		<tr>
			<td>Разница между feature detection, feature inference и анализом строки user-agent</td>
			<td>Определение возможностей браузера заключается в определении, поддерживает ли браузер определенный блок кода. Предположение возможностей проверяет на наличие определённых возможностей if (document.getElementsByTagName). User Agent
				Это строка, сообщаемая браузером, которая позволяет узлам сетевого протокола определить тип приложения, операционную систему, поставщика программного обеспечения или версию программного обеспечения пользователя</td>
		</tr>
		<tr>
			<td>Разница между e.preventDefault() и e.stopPropagation()</td>
			<td>Первый предотвращает действия браузера, установленные по умолчанию, а второй — дефолтное поведение событий — распространение вверх по дереву</td>
		</tr>
		<tr>
			<td>Разница между event.target и event.currentTarget</td>
			<td>event. target – самый глубокий элемент, на котором произошло событие. event. currentTarget (= this ) – элемент, на котором в данный момент сработал обработчик</td>
		</tr>
		<tr>
			<td>Разница между .stopPropagation() и .stopImmediatePropagation()</td>
			<td>stopPropagation(), который останавливает всплытие (bubbling). stopImmediatePropagation() останавливает не только всплытие события по родительским элементам, но также останавливает работу всех последующих обработчиков конкретного события на данном элементе</td>
		</tr>
		<tr>
			<td>Разница между событиями load и DOMContentLoaded? DOMContentLoaded</td>
			<td>событие происходит, когда браузер разобрал HTML-страницу и составил DOM-дерево; load — событие происходит, когда загрузилась и HTML страница, и все ресурсы для её отображения пользователю: стили, картинки и так далее</td>
		</tr>
		<tr>
			<td>Разница между innerHTML и outerHTML</td>
			<td>Свойство outerHTML содержит HTML элемента целиком. Это как innerHTML плюс сам элемент. Будьте осторожны: в отличие от innerHTML , запись в outerHTML не изменяет элемент. Вместо этого элемент заменяется целиком во внешнем контексте</td>
		</tr>
		<tr>
			<td>Разница между JSON и XML</td>
			<td>XML сложнее и менее гибкий. JSON поддерживает числа, объекты, строки и логические массивы. XML поддерживает все типы данных JSON и дополнительные типы, такие как логические массивы, даты, изображения и пространства имен. JSON имеет меньший размер файлов и обеспечивает более быструю передачу данных</td>
		</tr>
		<tr>
			<td>Для чего используется свойство window.navigator</td>
			<td>Window. navigator является свойством только для чтения и возвращает ссылку на объект Navigator , который может запросить информацию о приложении, запустившем скрипт</td>
		</tr>
		<tr>
			<td>Для чего используется свойство .forms</td>
			<td>Свойство Form используется для ссылки на форму или для ссылки на форму, связанную с вложенным элементом управления. Форма только для чтения</td>
		</tr>
		<tr>
			<td>Для чего используется метод .scrollIntoView()</td>
			<td>scrollIntoView() Метод Element. scrollIntoView() интерфейса Element прокручивает контейнер родителя элемента так, чтобы элемент, на котором был вызван scrollIntoView() , стал виден пользователю</td>
		</tr>
		<tr>
			<td>Разница между методами .submit() и .requestSubmit()</td>
			<td>.requestSubmit() — это альтернативный способ отправки формы с использованием JavaScript, но, в отличие от .submit(), валидация HTML-формы предотвратит отправку формы</td>
		</tr>
		<tr>
			<td>IntersectionObserver</td>
			<td>Intersection Observer — браузерный API, который позволяет асинхронно отслеживать пересечение элемента с его родителем или областью видимости документа (viewport)</td>
		</tr>
		<tr>
			<td>URLSearchParams</td>
			<td>класс, предоставляющий удобное API для формирования строки поисковых параметров, которую потом можно использовать для формирования полного адреса</td>
		</tr>
		<tr>
			<td>AJAX</td>
			<td>нет необходимости обновлять каждый раз всю страницу, так как обновляется только ее конкретная часть</td>
		</tr>
		<tr>
			<td>same-origin policy в контексте JavaScript</td>
			<td>Политика одинакового источника (same-origin policy) определяет как документ или скрипт, загруженный из одного источника (origin), может взаимодействовать с ресурсом из другого источника</td>
		</tr>
		<tr>
			<td>цикл событий (event loop) и как он работает</td>
			<td>Event Loop выполняет одну простую задачу — осуществляет контроль стека вызовов и очереди обратных вызовов. Если стек вызовов пуст, цикл событий возьмет первое событие из очереди и отправит его в стек вызовов, который его запустит. При вызове нового метода вверху стека выделяется отдельный блок памяти</td>
		</tr>
		<tr>
			<td>микро и макрозадачами</td>
			<td>у микрозадач есть приоритет перед макрозадачами. Они выполняются только после того, как выполнились все микрозадачи. Event loop переходит в очередь макрозадач — и затем снова после макрозадачи выполняются все микро</td>
		</tr>
		<tr>
			<td>queueMicrotask</td>
			<td>добавляет переданную функцию в очередь микрозадач</td>
		</tr>
		<tr>
			<td>промисы</td>
			<td>Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.
				Внешний код, получив promise, навешивает на него обработчики.
				По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде</td>
		</tr>
	</table>

	<h2>Массивы</h2>
	<table>
		<tr>
			<td>методы</td>
			<td>
				<ol>
					<li>добавление push, unhift, pop, shift</li>
					<li>some - удовлетворяет ли какой-либо элемент массива условию</li>
					<li>reduce - метод принимает функцию, которая имеет в качестве аргумента аккумулятор и значение</li>
					<li>every - метод проверяет, удовлетворяют ли все элементы массива условию </li>
					<li>map - метод принимает функцию в качестве параметра и создает новый массив с результатом вызова указанной функции для каждого элемента массива </li>
					<li>flat - метод принимает в качестве аргумента массив массивов и сглаживает вложенные массивы в массив верхнего уровня</li>
					<li>filter - метод принимает функцию в качестве параметра и возвращает новый массив, содержащий все элементы массива, для которого функция фильтрации передавалась в качестве аргумента, и возвращает ее со значением true. </li>
					<li>forEach - метод применяет функцию к каждому элементу массива. </li>
					<li>findIndex - метод принимает функцию в качестве параметра и в дальнейшем применяет ее к массиву. Он возвращает индекс найденного элемента, если элемент удовлетворяет условию проверяющей функции, переданной в качестве аргумента. Если не удовлетворяет, возвращается –1.
					</li>
					<li>find - метод принимает функцию в качестве аргумента и в дальнейшем применяет ее к массиву. Он возвращает значение элемента, найденного в массиве, если элемент удовлетворяет условию проверяющей функции. В противном случае оно возвращается со значением undefined. </li>
					<li>sort - метод принимает функцию в качестве параметра. Он сортирует элементы массива и возвращает их. </li>
					<li>concat - метод объединяет два или более массива/значения и возвращает новый массив. </li>
					<li>fill - метод заполняет все элементы массива одинаковым значением, от начального индекса (по умолчанию 0) до конечного индекса (по умолчанию array.length). </li>
					<li>includes -метод возвращает значение true, если массив содержит определенный элемент, и значение false — если нет. </li>
					<li>reverse - метод меняет порядок следования элементов в массиве на обратный. Первый элемент становится последним, а последний — первым.
					</li>
					<li>flatMap - метод применяет функцию к каждому элементу массива, а затем сглаживает результат в новый массив. Он объединяет метод flat() и метод map() в одну функцию. </li>
					<li>Map – это коллекция ключ/значение, запись, возврат, проверка ключа, удаление, очистка, размер коллекции, объекты как ключи</li>
					<li>Map из Object, Object из Map - Object.entries</li>
					<li>Object.fromEntries(array) на результате, чтобы преобразовать [] обратно в объект</li>
					<li>Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.</li>
					<li>WeakMap – это Map-подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями.

						WeakSet – это Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями</li>
					<li>[a, b, ...] - Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.</li>
					<li>Остаточные параметры let [name1, name2, ...rest], Math.max(...arr), для слияния массивов, [...str] строка в массив символов</li>
					<li>Что такое псевдомассив arguments? Псевдомассив arguments содержит список аргументов, переданных функции при вызове, но количество переданных аргументов может не совпадать с количеством объявленных параметров и это не приведет к ошибке.</li>
					<li>Назовите способы преобразования массива в объект? Преобразование массива в объект в JavaScript Object.assign() (...) Цикл for reduce() Object.fromEntries</li>
					<li>Для чего используется свойство .dataset? Свойство . dataset , позволяет считывать, или устанавливать любые дата-атрибуты на HTML-элементе</li>
				</ol>
			</td>
		</tr>
	</table>

	<h2>Функции</h2>
	<table>
		<tr>
			<td>unction declaration и function expression</td>
			<td>Декларация функции (Function Declaration) создается до выполнения любого кода</td>
		</tr>
		<tr>
			<td>функции высшего порядка</td>
			<td>которые работают с другими функциями</td>
		</tr>
		<tr>
			<td>функции называют объектами первого класса</td>
			<td>объекты, то есть могут быть переданы другим функциям и их можно вернуть из функций</td>
		</tr>
		<tr>
			<td>IIFE</td>
			<td>функция, которая выполняется сразу же после того, как она была определена</td>
		</tr>
		<tr>
			<td>мемоизация</td>
			<td>сохранение результатов выполнения функций для предотвращения повторных вычислений. Это один из способов оптимизации, применяемый для увеличения скорости выполнения компьютерных программ</td>
		</tr>
		<tr>
			<td>callback</td>
			<td>функция, которая выполняется после выполнения другой функции</td>
		</tr>
		<tr>
			<td>async/await</td>
			<td>async один простой смысл: эта функция всегда возвращает промис. Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится</td>
		</tr>
		<tr>
			<td>Promise.all(), Promise.any() и Promise.race()</td>
			<td>Promise.all() возвращает единый объект Promise, который объединяет набор промисов. Функция Promise.race() также принимает несколько промисов, только возвращает первый завершенный промис (вне зависимости завершился от успешно или с ошибкой) Функция Promise.any() принимает несколько промисов и возвращает первый успешно завершившийся промис</td>
		</tr>
		<tr>
			<td>.allSettled()</td>
			<td>дин из статических методов объекта Promise . Его используют, когда нужно запустить несколько промисов параллельно и дождаться их выполнения</td>
		</tr>
	</table>

	<h2>Числа</h2>
	<table>
		<tr>
			<td>В каком формате хранятся числа</td>
			<td>64-битном формате IEEE-754</td>
		</tr>
		<tr>
			<td>Bigint</td>
			<td>(2**53-1)</td>
		</tr>
		<tr>
			<td>большое/маленькое число</td>
			<td>let billion = 1e9 let ms = 1e-6</td>
		</tr>
		<tr>
			<td>шестнадцатеричные</td>
			<td>представления цветов, кодировки символов 0xff</td>
		</tr>
		<tr>
			<td>двоичные, восьмеричные</td>
			<td>let a = 0b11111111 let b = 0o377</td>
		</tr>
		<tr>
			<td>строковое представление в системе base</td>
			<td>num.toString(base)</td>
		</tr>
		<tr>
			<td>Округление</td>
			<td>Math.floor ceil round trunc</td>
		</tr>
		<tr>
			<td>округляет число до n</td>
			<td>toFixed(n)</td>
		</tr>
	</table>

	<h2>Объекты</h2>
	<table>
		<tr>
			<td>Перебор</td>
			<td>key in obj</td>
		</tr>
		<tr>
			<td>alert(user?.address?.street)</td>
			<td></td>
		</tr>
		<tr>
			<td>перебрать объект, нужно добавить </td>
			<td>object[Symbol.iterator] = function()</td>
		</tr>
		<tr>
			<td>Превратить объект, строку в массив</td>
			<td>Array.from</td>
		</tr>
		<tr>
			<td>Простые объекты</td>
			<td>Object.keys, values, entries</td>
		</tr>
		<tr>
			<td>JSON</td>
			<td>формат данных, который имеет собственный независимый стандарт и библиотеки для большинства языков программирования.
				JSON поддерживает простые объекты, массивы, строки, числа, логические значения и null.</td>
		</tr>
		<tr>
			<td>наличие свойства в объекте</td>
			<td>in или метод объекта hasOwnProperty()</td>
		</tr>
		<tr>
			<td>Нативные объекты</td>
			<td>String , Math , RegExp , Object , Function</td>
		</tr>
		<tr>
			<td>Wrapper Objects</td>
			<td>Временный объект отбрасывается по завершении работы со свойством или методом</td>
		</tr>
		<tr>
			<td>in и методом .hasOwnProperty()</td>
			<td>«in» проверяет наличие свойства не только в самом объекте, но и в его прототипах, hasOwnProperty — только в объекте</td>
		</tr>
		<tr>
			<td>прототип объекта</td>
			<td>механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга</td>
		</tr>
		<tr>
			<td>Object.create()</td>
			<td>Object. create(proto[, descriptors]) – создаёт пустой объект со свойством [[Prototype]] , указанным как proto (может быть null ), и необязательными дескрипторами свойств</td>
		</tr>
		<tr>
			<td>Object.freeze() и Object.seal()</td>
			<td>Object.seal() запечатывает объект, предотвращая добавление новых свойств к объекту и делая все существующие свойства не настраиваемыми, Object.freeze() замораживает объект</td>
		</tr>
		<tr>
			<td>typeof, Instanceof</td>
			<td>возвращает тип объекта, над которым он работает, возвращает true, если объект создан из данного конструктора, и false в противном случае</td>
		</tr>
		<tr>
			<td>Array. from()</td>
			<td>позволяет вам создавать массивы из: массивоподобных объектов (объектов со свойством length и элементами по индексным ключам) или итерируемых объектов (объектов, из которых вы можете достать их элементы, например Map (en-US) или Set )</td>
		</tr>
	</table>

	<h2>Строки</h2>
	<table>
		<tr>
			<td>Методы и особенности</td>
			<td>
				<ol>
					<li>Типы кавычек</li>
					<li>Неизменяемость строк</li>
					<li>Спецсимволы \</li>
					<li>Доступ к символам</li>
					<li>Сравнение строк</li>
					<li>Длина строки</li>
					<li>str.toLowerCase() и str.toUpperCase()</li>
					<li>str.slice Получение подстроки</li>
					<li>startsWith, endsWith</li>
					<li>~2</li>
					<li>str.codePointAt(pos) возвращает неотрицательное целое число, являющееся закодированным в UTF-16</li>
					<li>str.fromCodePoint(code) возвращает строку, созданную из указанной последовательности кодовых точек</li>
					<li>str.concat</li>
					<li>str.includes</li>
					<li>str.indexOf</li>
					<li>str.search</li>
					<li>str.replace</li>
					<li>str.padEnd str.padStart</li>
					<li>str.trim</li>
					<li>str.charCodeAt возвращает числовое значение Юникода для символа по указанному индексу </li>
				</ol>
			</td>
		</tr>

	</table>

	<h2>CSS (вопросы по каскадным таблицам стилей)</h2>
	<table>
		<tr>
			<td>position</td>
			<td>STATIC. RELATIVE. ABSOLUTE. FIXED. STICY</td>
		</tr>
		<tr>
			<td>Вендорные префиксы</td>
			<td>приставки перед свойствами</td>
		</tr>
		<tr>
			<td>initial</td>
			<td>сбрасывает все указанные значения свойства для конкретного блока</td>
		</tr>
		<tr>
			<td>inherit</td>
			<td>позволяет явно задать наследуемость какого-то из свойств</td>
		</tr>
		<tr>
			<td>currentColor</td>
			<td>значение color для свойств, которые не получают его по умолчанию</td>
		</tr>
		<tr>
			<td>8 CSS фильтров</td>
			<td> для изображений
				grayscale(% | число)
				sepia(% | число)
				blur(px)
				brightness (% | число)
				contrast(% | число)
				saturate(% | число)
				hue-rotate(deg)
				invert(% | число)</td>
		</tr>
		<tr>
			<td>text-rendering</td>
			<td>что оптимизировать при рендеринге текста</td>
		</tr>
		<tr>
			<td>pointer-events</td>
			<td>позволяет управлять тем, как элементы будут реагировать на события мыши или прикосновения к сенсорному экрану</td>
		</tr>
		<tr>
			<td>outline</td>
			<td>задаёт дополнительную рамку вокруг элемента</td>
		</tr>
		<tr>
			<td>scrollbar-gutter</td>
			<td>позволяет авторам резервировать пространство для полосы прокрутки</td>
		</tr>
		<tr>
			<td>Цвет</td>
			<td>RGB, RGBA, HSL, HSLA</td>
		</tr>
	</table>

	<h2>Typescript</h2>
	<table>
		<tr>
			<td>TypeScript</td>
			<td>отличается от JavaScript возможностью явного статического назначения типов, поддержкой использования полноценных классов (как в традиционных объектно-ориентированных языках), а также поддержкой подключения модулей, что призвано повысить скорость разработки, облегчить читаемость, рефакторинг и повторное использование кода, помочь осуществлять поиск ошибок на этапе разработки и компиляции, и, возможно, ускорить выполнение программ</td>
		</tr>
		<tr>
			<td>Аннотации типов и проверка их согласования на этапе компиляции</td>
			<td>Вывод типов
				Классы
				Интерфейсы
				Перечисляемые типы
				Примесь
				обобщённое программирование
				Модули
				Сокращенный синтаксис «стрелок» для анонимных функций
				Дополнительные параметры и параметры по умолчанию
				Кортежи</td>
		</tr>
		<tr>
			<td>Декораторы</td>
			<td>позволяют добавить к классам и их членам метаданные и тем самым изменить их поведение без изменения их кода</td>
		</tr>
		<tr>
			<td>(type) и интерфейсом (interface)</td>
			<td>с type у нас может быть объединение нескольких других type</td>
		</tr>
		<tr>
			<td>JSX</td>
			<td>встраиваемый XML-подобный синтаксис, который позволяет создавать HTML</td>
		</tr>
		<tr>
			<td>директивы с тремя наклонными чертами (Triple-Slash Directives), их типы?</td>
			<td>однострочными комментариями, включающими в себя единственный тэг XM /// reference path="..." /</td>
		</tr>
		<tr>
			<td>Внешнее объявление переменной</td>
			<td>механизм, который позволяет сообщать компилятору TypeScript о том, что некий исходный код существует где-то за пределами текущего файла</td>
		</tr>
		<tr>
			<td>Разница между абстрактным классом (abstract class) и интерфейсом (interface)?</td>
			<td>Абстрактный класс — это класс, у которого не реализован один или больше методов (некоторые языки требуют такие методы помечать специальными ключевыми словами). Интерфейс — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных класса</td>
		</tr>
		<tr>
			<td>Какие элементы ООП поддерживаются в TypeScript?</td>
			<td>Number.
				String.
				Boolean.
				Array.
				Enum.
				Any.
				Void.</td>
		</tr>
		<tr>
			<td>Модификаторы доступа в TypeScript?</td>
			<td>public, protected и private.</td>
		</tr>
		<tr>
			<td>внутренним (Internal Module)</td>
			<td>Внутренние модули появились в ранней версии Typescript. Их использовали для того, чтобы логически сгруппировать классы, интерфейсы, функции в один элемент и экспортировать в другой модуль namespace TutorialPoint {
				export function add(x, y) { console.log(x + y);}
				}</td>
		</tr>
		<tr>
			<td>внешним модулями (External Module)</td>
			<td>Внешние модули в TypeScript были созданы для того, чтобы задавать и загружать зависимости между множественными внешними js-файлами
				export interface SomeInterface {
				//объявление кода
				}</td>
		</tr>
		<tr>
			<td>Как TypeScript поддерживает необязательные и дефолтные параметры в функции?</td>
			<td>last?: string</td>
		</tr>
		<tr>
			<td>enum</td>
			<td>конструкция представляющая из себя список именованных констант</td>
		</tr>
		<tr>
			<td>noImplicitAny</td>
			<td>Это первый флаг, который необходимо активировать в начале работы над проектом с TypeScript.</td>
		</tr>
		<tr>
			<td>Разница между типами “Объединение” (|) и “Пересечение” (&#38;)?</td>
			<td>Объединение (Union) - это мощный механизм, позволяющий создавать из множества существующих типов логическое условие let v1: T1 | T2 | T3;</td>
		</tr>
		<tr>
			<td>Пересечение</td>
			<td>Пересечение (Intersection) — ещё один мощный механизм TypeScript, который позволяет рассматривать множество типов данных как единое целое. let name: A &#38; B &#38; C; // значение должно принадлежать ко всем типам одновременно</td>
		</tr>
		<tr>
			<td>Дженерики</td>
			<td>обобщенные типы. Они нужны для описания похожих, но отличающихся какими-то характеристиками типов</td>
		</tr>
		<tr>
			<td>Что такое .map файл, как и зачем его использовать?</td>
			<td>это файлы игр, сохраненные в текстовом формате</td>
		</tr>
		<tr>
			<td>Можно ли использовать TypeScript в серверной разработке?</td>
			<td>после компиляции программу на TypeScript можно выполнять в любом современном браузере или использовать совместно с серверной платформой Node</td>
		</tr>
		<tr>
			<td>Для чего в TypeScript используют ключевое слово declare?</td>
			<td>С помощью ключевого слова declare в программу на TS подключается определение глобальной переменной</td>
		</tr>
		<tr>
			<td>Разница между типами void, never и unknown?</td>
			<td>Тип данных Void можно назвать полной противоположностью типа any, так как этот тип означает отсутствие конкретного типа. Примитивный типа данных Never служит для указания того, что какие-либо операции никогда не будут выполнены. Все типы совместимы с типом unknown, в то время как сам тип unknown совместим только с самим собой и типом any</td>
		</tr>
	</table>

	<h2>VUE</h2>
	<table>
		<tr>
			<td>VUE</td>
			<td>прогрессивный фреймворк</td>
		</tr>
		<tr>
			<td>особенности Vue.js?</td>
			<td>Vue подходит для небольших проектов, которым необходимо добавить немного реактивности, представить форму с помощью AJAX, отобразить значения при вводе данных пользователем, авторизация или другие аналогичные задачи.</td>
		</tr>
		<tr>
			<td>Перечислите преимущества Vue.js?</td>
			<td>
				<ol>
					<li>достаточно быстрая разработка</li>
					<li>небольшой вес фреймворка</li>
					<li>хороша документация</li>
					<li>большое сообщество разработчиков</li>
					<li>быстрое взаимодействие с виртуальным DOM</li>
					<li>подключение плагинов и создание своих плагинов</li>
					<li>компонентная разработка приложения</li>
					<li>реализует современные подходы к разработке</li>
				</ol>
			</td>
		</tr>
		<tr>
			<td>хуки жизненного цикла</td>
			<td>
				<ol>
					<li>beforeCreate</li>
					<li>created</li>
					<li>beforeMount</li>
					<li>mounted</li>
					<li>beforeUpdate</li>
					<li>updated</li>
					<li>beforeUnmount</li>
					<li>unmounted</li>
					<li>errorCaptured</li>
					<li>renderTracked</li>
					<li>renderTriggered</li>
					<li>activated</li>
					<li>deactivated</li>
				</ol>
			</td>
		</tr>
		<tr>
			<td>жизненный цикл компонента</td>
			<td>
				<ol>
					<li>конструктор new Vue()</li>
					<li>beforeCreate</li>
					<li>инициализация объекта Vue</li>
					<li>created</li>
					<li>компиляция шаблона</li>
					<li>beforeMount</li>
					<li>Элемент html, к которому прикреплен объект Vue, заменяется скомпилированным шаблоном</li>
					<li>mounted</li>
					<li>beforeUpdate</li>
					<li>updated</li>
					<li>beforeDestroy</li>
					<li>destroyed</li>
				</ol>
			</td>
		</tr>
		<tr>
			<td>Что такое условные директивы (conditional directives)?</td>
			<td>Директива v-if позволяет по условию изменять структуру DOM на веб-странице</td>
		</tr>
		<tr>
			<td>Разница между директивами v-show и v-if?</td>
			<td>v-if выводит элементы в DOM только в случае, если выражение проходит, а v-show отображает все элементы</td>
		</tr>
		<tr>
			<td>Какие модификаторы событий предоставляет Vue.js?</td>
			<td>stop.
				prevent.
				capture.
				self.
				once.
				passive.</td>
		</tr>
		<tr>
			<td>Какие модификаторы кнопок предоставляет Vue.js?</td>
			<td>enter.
				tab.
				delete (ловит как «Delete», так и «Backspace»)
				esc.
				space.
				up.
				down.
				left.</td>
		</tr>
		<tr>
			<td>Какие модификаторы кнопок мыши предоставляет Vue.js?</td>
			<td>ctrl.
				alt.
				shift.
				meta.</td>
		</tr>
		<tr>
			<td>Что такое пропсы? Типы пропсов?</td>
			<td>кастомный атрибут, который вы можете зарегистрировать в любом компоненте. Вы определяете данные в родительском компоненте и присваиваете им определенное значение</td>
		</tr>
		<tr>
			<td>Разница между локальной и глобальной регистрацией компонента?</td>
			<td>лобальные компоненты доступны для любого объекта Vue на веб-странице. Локальные компоненты доступны только в рамках определенных объектов Vue</td>
		</tr>
		<tr>
			<td>Что такое миксины Vue.js?</td>
			<td>гибкий инструмент повторного использования кода в компонентах Vue</td>
		</tr>
		<tr>
			<td>Что такое Vue CLI?</td>
			<td>npm-пакет, устанавливаемый глобально и предоставляющий команду vue в терминале</td>
		</tr>
		<tr>
			<td>Что такое Vuex?</td>
			<td>паттерн управления состоянием + библиотека для приложений на Vue.js. централизованным хранилищем данных для всех компонентов приложения с правилами, гарантирующими, что состояние может быть изменено только предсказуемым образом.</td>
		</tr>
		<tr>
			<td>Что общего у React и Vue.js?</td>
			<td>Они оба имеют компонентно-ориентированный подход, который позволяет разбивать приложение на меньшие, легко повторно используемые и тестируемые части.</td>
		</tr>
		<tr>
			<td>Разница между React и Vue.js?</td>
			<td>React, разработанный Facebook, используется для создания компонентно-ориентированных приложений. Vue, написанный Эваном Яо, используется для создания простых и гибких приложений.</td>
		</tr>
		<tr>
			<td>Разница между Angular и Vue.js?</td>
			<td>Angular - это фреймворк, который идеально подходит для разработки крупногабаритных проектов, а Vue. js - это прогрессивный фреймворк, который идеально подходит для легких одностраничных проектов.</td>
		</tr>
		<tr>
			<td>Что такое Vue Router? Назовите его особенности?</td>
			<td>официальная библиотека маршрутизации для Vue. js</td>
		</tr>
		<tr>
			<td>Что такое фильтры? Как создать цепочку фильтров?</td>
			<td>Они находят своё применение в двух местах: в mustache-интерполяциях и в выражениях v-bind (последнее поддерживается в 2.1.0+). Фильтры добавляются в конце выражения JavaScript и отделяются вертикальной чертой: v-bind:id="rawId | formatId"</td>
		</tr>
		<tr>
			<td>Перечислите варианты коммуникации компонентов во Vue.js?</td>
			<td>от родительского элемента к дочернему информация передается через пропсы, а обратно — вызываются события.</td>
		</tr>
		<tr>
			<td>Какие модификаторы поддерживаются в модели (v-model)?</td>
			<td>КАРДИНАЛЬНОЕ ИЗМЕНЕНИЕ: При использовании на компонентах v-model поменялись входной параметр и имя события:
входной параметр: value -> modelValue;
событие: input -> update:modelValue;
КАРДИНАЛЬНОЕ ИЗМЕНЕНИЕ: Модификатор .sync для v-bind и опция компонента model были удалены и заменяются возможностью указать аргумент v-model;
НОВОЕ: Теперь возможны несколько привязок v-model на одном компоненте;
НОВОЕ: Добавлена возможность создавать собственные модификаторы для v-model.</td>
		</tr>
		<tr>
			<td>Что такое плагины? Какие возможности дают плагины для Vue.js?</td>
			<td>самодостаточная единица кода, которая добавляет во Vue функциональность глобального уровня</td>
		</tr>
		<tr>
			<td>Что такое слот (slot) во Vue.js?</td>
			<td>Слоты могут содержать любой код шаблона, в том числе HTML</td>
		</tr>
		<tr>
			<td>Какие хуки предоставляют директивы?</td>
			<td>bind - вызывается при привязке директивы к элементу. Вызывается только один раз.
inserted - вызывается после того, как элемент вставлен в родительский DOM.
update - вызывается при обновлениях элемента, но дочерние ещё не будут обновлены.
componentUpdated - вызывается после обновления компонента и его потомков.
unbind - вызывается после удаления директивы. Также вызывается только один раз.</td>
		</tr>
		<tr>
			<td>Что такое vue-loader?</td>
			<td>Позволяет использовать разнообразные загрузчики webpack для разных секций компонента Vue, например Sass для style и Pug для template</td>
		</tr>
		<tr>
			<td>Что такое рендер-функция (render function)? Преимущества рендер-функции?</td>
			<td>возникает необходимость в использовании всех алгоритмических возможностей JavaScript. В таких случаях можно применить render-функции — более низкоуровневую альтернативу шаблонам.</td>
		</tr>
		<tr>
			<td>Что такое динамические (keep-alive) компоненты?</td>
			<td>При выборе и переключении, выбранный таб останется прежним</td>
		</tr>
		<tr>
			<td>Асинхронные компоненты</td>
			<td>В больших приложениях может потребоваться разделять приложение на меньшие части и загружать компоненты с сервера только когда они необходимы. Для реализации подобного Vue предоставляет метод defineAsyncComponent</td>
		</tr>
	</table>

</body>

</html>
