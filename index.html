<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Title</title>
	<link rel="stylesheet" href="main.css">
</head>

<body>
	<ol>
		<li><a href="oopfpweb.html">Web Technologies, Web API, OOP & FP, </a></li>
		<li><a href="vuetypescript.html">VUE Typescript</a></li>
		<li><a href="practice.html">practice</a></li>
	</ol>
	
	<h2>HTML</h2>
	<table>
		<tr>
			<td>Глобальные атрибуты</td>
			<td>
				<ol>
					<li>class</li>
					<li>data-*</li>
					<li>dir (en-US)</li>
					<li>hidden (en-US)</li>
					<li>id</li>
					<li>lang</li>
					<li>style</li>
					<li>tabindex</li>
					<li>title (en-US)</li>
					<li>translate (en-US)</li>
				</ol>
			</td>
		</tr>
		<tr>
			<td>категории контента</td>
			<td>
				<ol>
					<li>Метаданные</li>
					<li>Основной поток</li>
					<li>Секционный контент</li>
					<li>Заголовочный контент</li>
					<li>Фразовый контент</li>
					<li>Встроенный контент</li>
					<li>Интерактивный контент</li>
					<li>Явный контент</li>
					<li>Контент форм</li>
					<li></li>
				</ol>
			</td>
		</tr>
		<tr>
			<td>Метатеги</td>
			<td>элементы (html-теги) веб страницы, используемые для передачи структурированных метаданных, как правило, размещаются в разделе head (заголовок, ключевые слова, описание страницы и другие служебные данные)</td>
		</tr>
		<tr>
			<td>viewport</td>
			<td>сообщает браузеру о том, как именно обрабатывать размеры страницы, и изменять её масштаб</td>
		</tr>
		<tr>
			<td>picture</td>
			<td>контейнером для одного или более элементов source и одного элемента img для обеспечения оптимальной версии изображения для различных размеров экрана</td>
		</tr>
		<tr>
			<td>srcset</td>
			<td>содержатся URL изображений и сведения об их ширине</td>
		</tr>
		<tr>
			<td>decoding</td>
			<td>интерфейса HTMLImageElement предназначено для указания браузеру, как он должен декодировать изображение</td>
		</tr>
		<tr>
			<td>enterkeyhint</td>
			<td>предоставляет браузеру подсказку об ожидаемом действии, когда пользователь нажимает клавишу Enter при взаимодействии с элементом ввода</td>
		</tr>
		<tr>
			<td>pattern</td>
			<td>определяет регулярное выражение, по которому проверяются вводимые данные</td>
		</tr>
	</table>
	
	<h2>CSS</h2>
	<table>
		<tr>
			<td>position</td>
			<td>STATIC. RELATIVE. ABSOLUTE. FIXED. STICY</td>
		</tr>
		<tr>
			<td>Вендорные префиксы</td>
			<td>приставки перед свойствами</td>
		</tr>
		<tr>
			<td>initial</td>
			<td>сбрасывает все указанные значения свойства для конкретного блока</td>
		</tr>
		<tr>
			<td>inherit</td>
			<td>позволяет явно задать наследуемость какого-то из свойств</td>
		</tr>
		<tr>
			<td>currentColor</td>
			<td>значение color для свойств, которые не получают его по умолчанию</td>
		</tr>
		<tr>
			<td>8 CSS фильтров</td>
			<td> для изображений
				grayscale(% | число)
				sepia(% | число)
				blur(px)
				brightness (% | число)
				contrast(% | число)
				saturate(% | число)
				hue-rotate(deg)
				invert(% | число)</td>
		</tr>
		<tr>
			<td>text-rendering</td>
			<td>что оптимизировать при рендеринге текста</td>
		</tr>
		<tr>
			<td>pointer-events</td>
			<td>позволяет управлять тем, как элементы будут реагировать на события мыши или прикосновения к сенсорному экрану</td>
		</tr>
		<tr>
			<td>outline</td>
			<td>задаёт дополнительную рамку вокруг элемента</td>
		</tr>
		<tr>
			<td>scrollbar-gutter</td>
			<td>позволяет авторам резервировать пространство для полосы прокрутки</td>
		</tr>
		<tr>
			<td>Цвет</td>
			<td>RGB, RGBA, HSL, HSLA</td>
		</tr>
	</table>

	<h2>Основы</h2>
	<pre>
script src="script.js"
script src="script2.js"
		
script src="script.js?v=1"
	
"use strict";
/*
комментарий
*/
	
str, my_str, myStr, a1, $, $a, $$a
	
let a;    // объявим переменную
a = 3;    // присвоим ей значение
alert(a); // выведем значение переменной на экран

alert(10 % 3); // выведет 1

alert(10 ** 3); // выведет 1000

let str = 'abc';

let str = 'abc' + 'def'; // складываем две строки
alert(str); // выведет 'abcdef'

alert(str.length); // выведет 6

let str = 'xxx';
let txt = `aaa ${str} bbb`;

let str = `abc
def`; // так будет работать

undefined, null, true, false, NaN, Infinity, -Infinity

const pi = 3.14;

alert('2' * '3'); // выведет 6

let a = '2';
let b = '3';
alert(a + b); // выведет '23'

let a = '2';
let b = '3';
alert(Number(a) + Number(b)); // выведет 5

let a = '2';
let b = +a; // в b запишется число 2

alert(Number('2s')); // выведет NaN

let num = parseInt('12px');
alert(num); // выведет 12

let num = parseFloat('12.5px');
alert(num); // выведет 12.5

let str = String(123); // теперь в переменной строка '123'

console.log(Boolean(0));          // false

let str = 'abcde';
alert(str[0]); // выведет 'a'

let str = 'abcde';
str[0] = '!';

let test = '12345';
alert(test[0] + test[1]); // выведет '12' - суммирует как строки

let test = 12345;
alert(test[0]); // выдаст undefined

let test = String(12345); // строка
alert(Number(test[0]) + Number(test[1])); // выведет 3

let num = 1;   // объявляем переменную num и записываем в нее значение 1
num = num + 2; // записываем в num ее саму плюс 2
alert(num);    // выведет 3

let num = 0;
num++;        // прибавляем к переменной a число 1
alert(num);   // выведет 1

let num = 0;
alert(++num); // выведет 1 - переменная увеличилась сразу
	</pre>
	
	<h2>Числа</h2>
	<table>
		<tr>
			<td>В каком формате хранятся числа</td>
			<td>64-битном формате IEEE-754</td>
		</tr>
		<tr>
			<td>Bigint</td>
			<td>(2**53-1)</td>
		</tr>
		<tr>
			<td>большое/маленькое число</td>
			<td>let billion = 1e9 let ms = 1e-6</td>
		</tr>
		<tr>
			<td>шестнадцатеричные</td>
			<td>представления цветов, кодировки символов 0xff</td>
		</tr>
		<tr>
			<td>двоичные, восьмеричные</td>
			<td>let a = 0b11111111 let b = 0o377</td>
		</tr>
		<tr>
			<td>строковое представление в системе base</td>
			<td>num.toString(base)</td>
		</tr>
		<tr>
			<td>Округление</td>
			<td>Math.floor ceil round trunc</td>
		</tr>
		<tr>
			<td>округляет число до n</td>
			<td>toFixed(n)</td>
		</tr>
	</table>

	<h2>Массивы</h2>
	<pre>
let arr = ['a', 'b', 'c'];
console.log(arr[0]); // выведет 'a'
console.log(arr.length) // выведет 3

let arr = ['a', 'b', 'c'];
arr[0] = '!';
console.log(arr); // выведет ['!', 'b', 'c']

let arr = ['a', 'b', 'c'];

arr[0] = arr[0] + '!';
arr[1] = arr[1] + '!';
arr[2] = arr[2] + '!';
console.log(arr); // выведет ['a!', 'b!', 'c!']



let arr = [1, 2, 3, 4];
arr[0]++;
++arr[1];
arr[2]--;
--arr[3];
console.log(arr); // выведет [2, 3, 2, 3]

let arr = [];
arr[0] = 'a';
arr[1] = 'b';
arr[2] = 'c';
console.log(arr); // выведет ['a', 'b', 'c']

let arr = ['a', 'b', 'c'];
arr[4] = '!';
console.log(arr); // выведет ['a', 'b', 'c', undefined, '!']

let arr = ['a', 'b', 'c'];
let key = 0; // запишем ключ в переменную
console.log(arr[key]); // выведет 'a'
	</pre>
	
	<h2>методы</h2>
	
<pre>
const myAwesomeArray = ["a", "b", "c", "d", "e"]
myAwesomeArray.some(test => test === "d")
//-------> Output : true


const myAwesomeArray = [1, 2, 3, 4, 5]
myAwesomeArray.reduce((total, value) => total * value)
// 1 * 2 * 3 * 4 * 5
//-------> Output = 120


const myAwesomeArray = ["a", "b", "c", "d", "e"]
myAwesomeArray.every(test => test === "d")
//-------> Output : false
const myAwesomeArray2 = ["a", "a", "a", "a", "a"]
myAwesomeArray2.every(test => test === "a")
//-------> Output : true


const myAwesomeArray = [5, 4, 3, 2, 1]
myAwesomeArray.map(x => x * x)
//-------> Output : 25
//                  16
//                  9
//                  4
//                  1


const myAwesomeArray = [[1, 2], [3, 4], 5]
myAwesomeArray.flat()
//-------> Output : [1, 2, 3, 4, 5]


const myAwesomeArray = [
  { id: 1, name: "john" },
  { id: 2, name: "Ali" },
  { id: 3, name: "Mass" },
  { id: 4, name: "Mass" },
]
myAwesomeArray.filter(element => element.name === "Mass")
//-------> Output : 0:{id: 3, name: "Mass"},
//                  1:{id: 4, name: "Mass"}


const myAwesomeArray = [
  { id: 1, name: "john" },
  { id: 2, name: "Ali" },
  { id: 3, name: "Mass" },
]
myAwesomeArray.forEach(element => console.log(element.name))
//-------> Output : john
//                  Ali
//                  Mass


const myAwesomeArray = [
  { id: 1, name: "john" },
  { id: 2, name: "Ali" },
  { id: 3, name: "Mass" },
]
myAwesomeArray.findIndex(element => element.id === 3)
//-------> Output : 2
myAwesomeArray.findIndex(element => element.id === 7)
//-------> Output : -1


const myAwesomeArray = [
  { id: 1, name: "john" },
  { id: 2, name: "Ali" },
  { id: 3, name: "Mass" },
]
myAwesomeArray.find(element => element.id === 3)
//-------> Output : {id: 3, name: "Mass"}
myAwesomeArray.find(element => element.id === 7)
//-------> Output : undefined


const myAwesomeArray = [5, 4, 3, 2, 1]
// Sort from smallest to largest
myAwesomeArray.sort((a, b) => a - b)
//-------> Output : [1, 2, 3, 4, 5]
// Sort from largest to smallest
myAwesomeArray.sort((a, b) => b - a)
//-------> Output : [5, 4, 3, 2, 1]


const myAwesomeArray = [1, 2, 3, 4, 5]
const myAwesomeArray2 = [10, 20, 30, 40, 50]
myAwesomeArray.concat(myAwesomeArray2)
//-------> Output : [1, 2, 3, 4, 5, 10, 20, 30, 40, 50]



const myAwesomeArray = [1, 2, 3, 4, 5]
// The first argument (0) is the value
// The second argument (1) is the starting index
// The third argument (3) is the ending index
myAwesomeArray.fill(0, 1, 3)
//-------> Output : [1, 0, 0, 4, 5]


const myAwesomeArray = [1, 2, 3, 4, 5]
myAwesomeArray.includes(3)
//-------> Output : true
myAwesomeArray.includes(8)
//-------> Output : false


const myAwesomeArray = ["e", "d", "c", "b", "a"]
myAwesomeArray.reverse()
//-------> Output : ['a', 'b', 'c', 'd', 'e']


const myAwesomeArray = [[1], [2], [3], [4], [5]]
myAwesomeArray.flatMap(arr => arr * 10)
//-------> Output : [10, 20, 30, 40, 50]
// With .flat() and .map()
myAwesomeArray.flat().map(arr => arr * 10)
//-------> Output : [10, 20, 30, 40, 50]

</pre>

	<h2>Объекты</h2>
	
	<pre>

let obj = {1: 'a', 2: 'b', 3: 'c'};
alert(obj); // выведет [Object object]

let obj = {'a': 1, 'b': 2, 'c': 3};
let obj = {a: 1, b: 2, c: 3};

let obj = {'1key': 'a', 'key-2': 'b', key3: 'c'};
console.log(obj['1key']);
console.log(obj['key-2']);

let obj = {};
obj['a'] = 1;

let obj = {3: 'c', 1: 'a', 2: 'b'};

console.log(obj[1]); // выведет 'a'
console.log(obj[2]); // выведет 'b'
console.log(obj[3]); // выведет 'c'

let obj = {a: 1, b: 2, c: 3};
let keys = Object.keys(obj);

let obj = {
	[key + '1']: 1,
	[key + '2']: 2,
	[key + '3']: 3
};


let obj = {a: 1, b: 2, c: 3};
console.log('b' in obj); // выведет true
console.log('x' in obj); // выведет false
	</pre>
	
	<h2>Условия</h2>
	<pre>
let test = 1;

if (test > 0) {
	console.log('+++'); // сработает это
} else {
	console.log('---');
}

if (3 !== 3) {
	console.log('+++');
} else {
	console.log('---'); // сработает это
}

if ('3' !== 3) {
	console.log('+++'); // сработает это
} else {
	console.log('---');
}

112!!





























	</pre>
	
	<h2>Функции</h2>

	<h2>Строки</h2>
	<table>
		<tr>
			<td>Методы и особенности</td>
			<td>
				<ol>
					<li>Типы кавычек</li>
					<li>Неизменяемость строк</li>
					<li>Спецсимволы \</li>
					<li>Доступ к символам</li>
					<li>Сравнение строк</li>
					<li>Длина строки</li>
					<li>str.toLowerCase() и str.toUpperCase()</li>
					<li>str.slice Получение подстроки</li>
					<li>startsWith, endsWith</li>
					<li>~2</li>
					<li>str.codePointAt(pos) возвращает неотрицательное целое число, являющееся закодированным в UTF-16</li>
					<li>str.fromCodePoint(code) возвращает строку, созданную из указанной последовательности кодовых точек</li>
					<li>str.concat</li>
					<li>str.includes</li>
					<li>str.indexOf</li>
					<li>str.search</li>
					<li>str.replace</li>
					<li>str.padEnd str.padStart</li>
					<li>str.trim</li>
					<li>str.charCodeAt возвращает числовое значение Юникода для символа по указанному индексу </li>
				</ol>
			</td>
		</tr>

	</table>

</body>

</html>
