<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
	<link rel="stylesheet" href="main.css">
</head>

<body>

	<h2>Основы</h2>

	<ol>
		<li>Подключение скриптов к html, относительных, внешних, подключение и внутреннее содержимое</li>
		<pre>
1.
&#60;script>
  alert( 'Привет, мир!' );
&#60;/script>
2.
&#60;script src="/path/to/script.js">&#60;/script>
3.
&#60;script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js">&#60;/script>
4.
&#60;script src="file.js">
  alert(1); // содержимое игнорируется, так как есть атрибут src
&#60;/script>
      </pre>
		<li>Комментарии (2 вида)</li>
		<pre>
// однострочные
/* многострочные
*/
      </pre>
		<li>Переменные (3 вида и разница)
		</li>
		<pre>
var
let
const
    </pre>
		<li>
			имена переменных (что может содержать, и запрещенные имена)
		</li>
		<pre>
1. буквы
2. цифры
3. $, _
4. зарезервированные
  </pre>
		<li>Типы данных (8)
		</li>
		<pre>
string
number
undefined
null
bigint
object
symbol
boolean
    </pre>
		<li>Взаимодействие с пользователем (3 вида)
		</li>
		<pre>
alert
prompt
confirm
    </pre>
		<pre>
Явное
Неявное
    </pre>
		<li>Математические операторы (12)
		</li>
		<pre>
*
/
+
-
%
**
++
--
Приоритет операторов
=
Побитовые операторы
Оператор запятая
    </pre>
		<li>Операторы сравнения (8)</li>
		<pre>
==
!=
===
!==
&#62;
&#62;=
&#60;
&#60;=
    </pre>
		<li>Условия (5)</li>
		<pre>
if
else
else if
switch case
?::
    </pre>
		<li>Логические операторы (5)</li>
		<pre>
||
&&
!!
!
??
    </pre>
		<li>Циклы (5 + остановка и продолжение)
		</li>
		<pre>
for(;;)
while
do while
for in
for of
break continue
    </pre>
		<li>
			Symbol для создания уникальных идентификаторов. Даже если символы имеют одно и то же имя, это – разные символы
		</li>
	</ol>


	<h2>Массивы</h2>
	<ol>
		<li>Создание массива arr = [];</li>
		<li>Получение элемента arr[0]</li>
		<li>замена элемента arr[2] = 'a';</li>
		<li>длина массива arr.length</li>
		<li>хранение любых данных строка, объект, функция</li>
		<li>массив копируется по ссылке</li>
		<li>перебор элементов for</li>
		<li>в строку</li>
		<pre>
let arr = [1, 2, 3];

alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
  </pre>
		<li>сравнение</li>
		<pre>
alert( [] == [] ); // false
alert( [0] == [0] ); // false

alert( 0 == [] ); // true

alert('0' == [] ); // false
  </pre>
	</ol>
	методы массивов
	<ol>

		<li>добавление в массив push, unhift, pop, shift</li>
		<li>удовлетворяет ли какой-либо элемент массива условию some</li>
		<li>метод принимает функцию, которая имеет в качестве аргумента аккумулятор и значение reduce</li>
		<li>метод проверяет, удовлетворяют ли все элементы массива условию every</li>
		<li>метод принимает функцию в качестве параметра и создает новый массив с результатом вызова указанной функции для каждого элемента массива map</li>
		<li>метод принимает в качестве аргумента массив массивов и сглаживает вложенные массивы в массив верхнего уровня flat</li>
		<li>метод принимает функцию в качестве параметра и возвращает новый массив, содержащий все элементы массива, для которого функция фильтрации передавалась в качестве аргумента, и возвращает ее со значением true. filter</li>
		<li>метод применяет функцию к каждому элементу массива. forEach</li>
		<li>метод принимает функцию в качестве параметра и в дальнейшем применяет ее к массиву. Он возвращает индекс найденного элемента, если элемент удовлетворяет условию проверяющей функции, переданной в качестве аргумента. Если не удовлетворяет, возвращается –1. findIndex
		</li>
		<li>метод принимает функцию в качестве аргумента и в дальнейшем применяет ее к массиву. Он возвращает значение элемента, найденного в массиве, если элемент удовлетворяет условию проверяющей функции. В противном случае оно возвращается со значением undefined. find</li>
		<li>метод принимает функцию в качестве параметра. Он сортирует элементы массива и возвращает их. sort</li>
		<li>метод объединяет два или более массива/значения и возвращает новый массив. concat</li>
		<li>метод заполняет все элементы массива одинаковым значением, от начального индекса (по умолчанию 0) до конечного индекса (по умолчанию array.length). fill</li>
		<li>метод возвращает значение true, если массив содержит определенный элемент, и значение false — если нет. includes</li>

		<li>метод меняет порядок следования элементов в массиве на обратный. Первый элемент становится последним, а последний — первым. reverse
		</li>
		<li>метод применяет функцию к каждому элементу массива, а затем сглаживает результат в новый массив. Он объединяет метод flat() и метод map() в одну функцию. flatMap</li>
	</ol>


	<h2>Functions</h2>
	<ol>
		<li>Объявление функции</li>
		<li>вызов</li>
		<li>локальные переменные</li>
		<li>доступ ко внешним</li>
		<li>Функция обладает полным доступом к внешним переменным и может изменять их значение.</li>
		<li>передать внутрь функции любую информацию, используя параметры</li>
		<li>значение по умолчанию</li>
		<li> оператор нулевого слияния</li>
		<li>Возврат значения</li>
		<li>Вызовов return может быть несколько</li>
		<li>Выбор имени функции</li>
	</ol>


	<h2>Числа</h2>
	<ol>

		<li>В каком формате хранятся числа? 64-битном формате IEEE-754</li>
		<li>Для чего нужен Bigint (2**53-1)</li>
		<li>Как укороченно записать большое/маленькое число let billion = 1e9 let ms = 1e-6</li>
		<li>шестнадцатеричные (для чего используются?) редставления цветов, кодировки символов 0xff</li>
		<li>двоичные, восьмеричные let a = 0b11111111 let b = 0o377</li>
		<li>строковое представление в системе base num.toString(base)</li>
		<li>Округление Math.floor ceil round trunc
			В большую
			В меньшую
			до ближайшего
			С удалением дробной части
		</li>
		<li>округляет число до n знаков после запятой и возвращает строковое представление результата toFixed(n)</li>
		<li>Проверка на isFinite isNaN</li>
		<li>parseInt и parseFloat</li>
		<li>Math
			<pre>
random
max
min
</pre>
		</li>
	</ol>
	
	
<h2>Objects</h2>
<ol>
  <li>Удаление свойства</li>
  <li>Добавление свойства</li>
  <li>Вычисление свойства</li>
  <li>Передача из функции</li>
  <li>Перебор key in obj</li>
  <li>Копирование объекта по ссылке</li>
  <li>Метод объекта и this(вычисляется во время компиляции)</li>
  <pre>
    sayHi() {
      alert(this.name)
    }
  </pre>
  <li>Конструктор</li>
  <li>return вместо this вернет {}</li>
  <li>return примитива проигнорируется</li>
  <li>alert(user?.address?.street)</li>
</ol>


	<h2>Строки</h2>

	<h3>Общее</h3>

	<ol>
		<li>Типы кавычек</li>
		<li>Неизменяемость строк</li>
		<li>Спецсимволы \</li>
		<li>Доступ к символам</li>
		<li>Сравнение строк</li>
	</ol>
	
	<h3>Методы строк</h3>
	
	<ol>
		<li>Длина строки</li>
		<li>str.toLowerCase() и str.toUpperCase()</li>
		<li>str.slice Получение подстроки</li>
		<li>startsWith, endsWith</li>
		<li>~2</li>
		<li>str.codePointAt(pos)</li>
		<li>str.fromCodePoint(code)</li>
		<li>str.concat</li>
		<li>str.includes</li>
		<li>str.indexOf</li>
		<li>str.search</li>
		<li>str.replace</li>
		<li>str.padEnd str.padStart</li>
		<li>str.trim</li>
		<li>str.charCodeAt</li>
	</ol>

</body></html>