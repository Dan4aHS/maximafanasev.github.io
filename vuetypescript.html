<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<link rel="stylesheet" href="main.css">

</head>
<body>
	
	<h2>Typescript</h2>
	<table>
		<tr>
			<td>TypeScript</td>
			<td>отличается от JavaScript возможностью явного статического назначения типов, поддержкой использования полноценных классов (как в традиционных объектно-ориентированных языках), а также поддержкой подключения модулей, что призвано повысить скорость разработки, облегчить читаемость, рефакторинг и повторное использование кода, помочь осуществлять поиск ошибок на этапе разработки и компиляции, и, возможно, ускорить выполнение программ</td>
		</tr>
		<tr>
			<td>Аннотации типов и проверка их согласования на этапе компиляции</td>
			<td>Вывод типов
				Классы
				Интерфейсы
				Перечисляемые типы
				Примесь
				обобщённое программирование
				Модули
				Сокращенный синтаксис «стрелок» для анонимных функций
				Дополнительные параметры и параметры по умолчанию
				Кортежи</td>
		</tr>
		<tr>
			<td>Декораторы</td>
			<td>позволяют добавить к классам и их членам метаданные и тем самым изменить их поведение без изменения их кода</td>
		</tr>
		<tr>
			<td>(type) и интерфейсом (interface)</td>
			<td>с type у нас может быть объединение нескольких других type</td>
		</tr>
		<tr>
			<td>JSX</td>
			<td>встраиваемый XML-подобный синтаксис, который позволяет создавать HTML</td>
		</tr>
		<tr>
			<td>директивы с тремя наклонными чертами (Triple-Slash Directives), их типы?</td>
			<td>однострочными комментариями, включающими в себя единственный тэг XM /// reference path="..." /</td>
		</tr>
		<tr>
			<td>Внешнее объявление переменной</td>
			<td>механизм, который позволяет сообщать компилятору TypeScript о том, что некий исходный код существует где-то за пределами текущего файла</td>
		</tr>
		<tr>
			<td>Разница между абстрактным классом (abstract class) и интерфейсом (interface)?</td>
			<td>Абстрактный класс — это класс, у которого не реализован один или больше методов (некоторые языки требуют такие методы помечать специальными ключевыми словами). Интерфейс — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных класса</td>
		</tr>
		<tr>
			<td>Какие элементы ООП поддерживаются в TypeScript?</td>
			<td>Number.
				String.
				Boolean.
				Array.
				Enum.
				Any.
				Void.</td>
		</tr>
		<tr>
			<td>Модификаторы доступа в TypeScript?</td>
			<td>public, protected и private.</td>
		</tr>
		<tr>
			<td>внутренним (Internal Module)</td>
			<td>Внутренние модули появились в ранней версии Typescript. Их использовали для того, чтобы логически сгруппировать классы, интерфейсы, функции в один элемент и экспортировать в другой модуль namespace TutorialPoint {
				export function add(x, y) { console.log(x + y);}
				}</td>
		</tr>
		<tr>
			<td>внешним модулями (External Module)</td>
			<td>Внешние модули в TypeScript были созданы для того, чтобы задавать и загружать зависимости между множественными внешними js-файлами
				export interface SomeInterface {
				//объявление кода
				}</td>
		</tr>
		<tr>
			<td>Как TypeScript поддерживает необязательные и дефолтные параметры в функции?</td>
			<td>last?: string</td>
		</tr>
		<tr>
			<td>enum</td>
			<td>конструкция представляющая из себя список именованных констант</td>
		</tr>
		<tr>
			<td>noImplicitAny</td>
			<td>Это первый флаг, который необходимо активировать в начале работы над проектом с TypeScript.</td>
		</tr>
		<tr>
			<td>Разница между типами “Объединение” (|) и “Пересечение” (&#38;)?</td>
			<td>Объединение (Union) - это мощный механизм, позволяющий создавать из множества существующих типов логическое условие let v1: T1 | T2 | T3;</td>
		</tr>
		<tr>
			<td>Пересечение</td>
			<td>Пересечение (Intersection) — ещё один мощный механизм TypeScript, который позволяет рассматривать множество типов данных как единое целое. let name: A &#38; B &#38; C; // значение должно принадлежать ко всем типам одновременно</td>
		</tr>
		<tr>
			<td>Дженерики</td>
			<td>обобщенные типы. Они нужны для описания похожих, но отличающихся какими-то характеристиками типов</td>
		</tr>
		<tr>
			<td>Что такое .map файл, как и зачем его использовать?</td>
			<td>это файлы игр, сохраненные в текстовом формате</td>
		</tr>
		<tr>
			<td>Можно ли использовать TypeScript в серверной разработке?</td>
			<td>после компиляции программу на TypeScript можно выполнять в любом современном браузере или использовать совместно с серверной платформой Node</td>
		</tr>
		<tr>
			<td>Для чего в TypeScript используют ключевое слово declare?</td>
			<td>С помощью ключевого слова declare в программу на TS подключается определение глобальной переменной</td>
		</tr>
		<tr>
			<td>Разница между типами void, never и unknown?</td>
			<td>Тип данных Void можно назвать полной противоположностью типа any, так как этот тип означает отсутствие конкретного типа. Примитивный типа данных Never служит для указания того, что какие-либо операции никогда не будут выполнены. Все типы совместимы с типом unknown, в то время как сам тип unknown совместим только с самим собой и типом any</td>
		</tr>
	</table>

	<h2>VUE</h2>
	<table>
		<tr>
			<td>VUE</td>
			<td>прогрессивный фреймворк</td>
		</tr>
		<tr>
			<td>особенности Vue.js?</td>
			<td>Vue подходит для небольших проектов, которым необходимо добавить немного реактивности, представить форму с помощью AJAX, отобразить значения при вводе данных пользователем, авторизация или другие аналогичные задачи.</td>
		</tr>
		<tr>
			<td>Перечислите преимущества Vue.js?</td>
			<td>
				<ol>
					<li>достаточно быстрая разработка</li>
					<li>небольшой вес фреймворка</li>
					<li>хороша документация</li>
					<li>большое сообщество разработчиков</li>
					<li>быстрое взаимодействие с виртуальным DOM</li>
					<li>подключение плагинов и создание своих плагинов</li>
					<li>компонентная разработка приложения</li>
					<li>реализует современные подходы к разработке</li>
				</ol>
			</td>
		</tr>
		<tr>
			<td>хуки жизненного цикла</td>
			<td>
				<ol>
					<li>beforeCreate</li>
					<li>created</li>
					<li>beforeMount</li>
					<li>mounted</li>
					<li>beforeUpdate</li>
					<li>updated</li>
					<li>beforeUnmount</li>
					<li>unmounted</li>
					<li>errorCaptured</li>
					<li>renderTracked</li>
					<li>renderTriggered</li>
					<li>activated</li>
					<li>deactivated</li>
				</ol>
			</td>
		</tr>
		<tr>
			<td>жизненный цикл компонента</td>
			<td>
				<ol>
					<li>конструктор new Vue()</li>
					<li>beforeCreate</li>
					<li>инициализация объекта Vue</li>
					<li>created</li>
					<li>компиляция шаблона</li>
					<li>beforeMount</li>
					<li>Элемент html, к которому прикреплен объект Vue, заменяется скомпилированным шаблоном</li>
					<li>mounted</li>
					<li>beforeUpdate</li>
					<li>updated</li>
					<li>beforeDestroy</li>
					<li>destroyed</li>
				</ol>
			</td>
		</tr>
		<tr>
			<td>Что такое условные директивы (conditional directives)?</td>
			<td>Директива v-if позволяет по условию изменять структуру DOM на веб-странице</td>
		</tr>
		<tr>
			<td>Разница между директивами v-show и v-if?</td>
			<td>v-if выводит элементы в DOM только в случае, если выражение проходит, а v-show отображает все элементы</td>
		</tr>
		<tr>
			<td>Какие модификаторы событий предоставляет Vue.js?</td>
			<td>stop.
				prevent.
				capture.
				self.
				once.
				passive.</td>
		</tr>
		<tr>
			<td>Какие модификаторы кнопок предоставляет Vue.js?</td>
			<td>enter.
				tab.
				delete (ловит как «Delete», так и «Backspace»)
				esc.
				space.
				up.
				down.
				left.</td>
		</tr>
		<tr>
			<td>Какие модификаторы кнопок мыши предоставляет Vue.js?</td>
			<td>ctrl.
				alt.
				shift.
				meta.</td>
		</tr>
		<tr>
			<td>Что такое пропсы? Типы пропсов?</td>
			<td>кастомный атрибут, который вы можете зарегистрировать в любом компоненте. Вы определяете данные в родительском компоненте и присваиваете им определенное значение</td>
		</tr>
		<tr>
			<td>Разница между локальной и глобальной регистрацией компонента?</td>
			<td>лобальные компоненты доступны для любого объекта Vue на веб-странице. Локальные компоненты доступны только в рамках определенных объектов Vue</td>
		</tr>
		<tr>
			<td>Что такое миксины Vue.js?</td>
			<td>гибкий инструмент повторного использования кода в компонентах Vue</td>
		</tr>
		<tr>
			<td>Что такое Vue CLI?</td>
			<td>npm-пакет, устанавливаемый глобально и предоставляющий команду vue в терминале</td>
		</tr>
		<tr>
			<td>Что такое Vuex?</td>
			<td>паттерн управления состоянием + библиотека для приложений на Vue.js. централизованным хранилищем данных для всех компонентов приложения с правилами, гарантирующими, что состояние может быть изменено только предсказуемым образом.</td>
		</tr>
		<tr>
			<td>Что общего у React и Vue.js?</td>
			<td>Они оба имеют компонентно-ориентированный подход, который позволяет разбивать приложение на меньшие, легко повторно используемые и тестируемые части.</td>
		</tr>
		<tr>
			<td>Разница между React и Vue.js?</td>
			<td>React, разработанный Facebook, используется для создания компонентно-ориентированных приложений. Vue, написанный Эваном Яо, используется для создания простых и гибких приложений.</td>
		</tr>
		<tr>
			<td>Разница между Angular и Vue.js?</td>
			<td>Angular - это фреймворк, который идеально подходит для разработки крупногабаритных проектов, а Vue. js - это прогрессивный фреймворк, который идеально подходит для легких одностраничных проектов.</td>
		</tr>
		<tr>
			<td>Что такое Vue Router? Назовите его особенности?</td>
			<td>официальная библиотека маршрутизации для Vue. js</td>
		</tr>
		<tr>
			<td>Что такое фильтры? Как создать цепочку фильтров?</td>
			<td>Они находят своё применение в двух местах: в mustache-интерполяциях и в выражениях v-bind (последнее поддерживается в 2.1.0+). Фильтры добавляются в конце выражения JavaScript и отделяются вертикальной чертой: v-bind:id="rawId | formatId"</td>
		</tr>
		<tr>
			<td>Перечислите варианты коммуникации компонентов во Vue.js?</td>
			<td>от родительского элемента к дочернему информация передается через пропсы, а обратно — вызываются события.</td>
		</tr>
		<tr>
			<td>Какие модификаторы поддерживаются в модели (v-model)?</td>
			<td>КАРДИНАЛЬНОЕ ИЗМЕНЕНИЕ: При использовании на компонентах v-model поменялись входной параметр и имя события:
				входной параметр: value -> modelValue;
				событие: input -> update:modelValue;
				КАРДИНАЛЬНОЕ ИЗМЕНЕНИЕ: Модификатор .sync для v-bind и опция компонента model были удалены и заменяются возможностью указать аргумент v-model;
				НОВОЕ: Теперь возможны несколько привязок v-model на одном компоненте;
				НОВОЕ: Добавлена возможность создавать собственные модификаторы для v-model.</td>
		</tr>
		<tr>
			<td>Что такое плагины? Какие возможности дают плагины для Vue.js?</td>
			<td>самодостаточная единица кода, которая добавляет во Vue функциональность глобального уровня</td>
		</tr>
		<tr>
			<td>Что такое слот (slot) во Vue.js?</td>
			<td>Слоты могут содержать любой код шаблона, в том числе HTML</td>
		</tr>
		<tr>
			<td>Какие хуки предоставляют директивы?</td>
			<td>bind - вызывается при привязке директивы к элементу. Вызывается только один раз.
				inserted - вызывается после того, как элемент вставлен в родительский DOM.
				update - вызывается при обновлениях элемента, но дочерние ещё не будут обновлены.
				componentUpdated - вызывается после обновления компонента и его потомков.
				unbind - вызывается после удаления директивы. Также вызывается только один раз.</td>
		</tr>
		<tr>
			<td>Что такое vue-loader?</td>
			<td>Позволяет использовать разнообразные загрузчики webpack для разных секций компонента Vue, например Sass для style и Pug для template</td>
		</tr>
		<tr>
			<td>Что такое рендер-функция (render function)? Преимущества рендер-функции?</td>
			<td>возникает необходимость в использовании всех алгоритмических возможностей JavaScript. В таких случаях можно применить render-функции — более низкоуровневую альтернативу шаблонам.</td>
		</tr>
		<tr>
			<td>Что такое динамические (keep-alive) компоненты?</td>
			<td>При выборе и переключении, выбранный таб останется прежним</td>
		</tr>
		<tr>
			<td>Асинхронные компоненты</td>
			<td>В больших приложениях может потребоваться разделять приложение на меньшие части и загружать компоненты с сервера только когда они необходимы. Для реализации подобного Vue предоставляет метод defineAsyncComponent</td>
		</tr>
	</table>

</body>
</html>