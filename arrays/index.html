<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<link rel="stylesheet" href=../main.css>
</head>

<body>
	<a href="../index.html">Home</a>
	<h1>Массивы</h1>
	<h2>Методы</h2>
	<ol>
		<li>split()</li>
		<pre>
1.
let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);

alert(arr); // Вася, Петя

2. 
let str = "тест";

alert( str.split('') ); // т,е,с,т
</pre>
		<li>join()</li>
		<pre>
let arr = ['Вася', 'Петя', 'Маша'];

let str = arr.join(';'); // объединить массив в строку через ;

alert( str ); // Вася;Петя;Маша
</pre>
		<li>slice()</li>
		<pre>
let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)

alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)
</pre>
		<li>splice()</li>
		<pre>
1.
let arr = ["Я", "изучаю", "JavaScript"];

arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент

alert( arr ); // осталось ["Я", "JavaScript"]

2.
let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

// удалить 2 первых элемента
let removed = arr.splice(0, 2);

alert( removed ); // "Я", "изучаю" &#60;-- массив из удалённых элементов

3. 
let arr = ["Я", "изучаю", "JavaScript"];

// с позиции 2
// удалить 0 элементов
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");

alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"
</pre>
		<li>some()</li>
		<pre>
const myAwesomeArray = ["a", "b", "c", "d", "e"]

myAwesomeArray.some(test => test === "d")
//-------> Output : true
</pre>
		<li>reduce()</li>
		<pre>
const myAwesomeArray = [1, 2, 3, 4, 5]

myAwesomeArray.reduce((total, value) => total * value)
// 1 * 2 * 3 * 4 * 5
//-------> Output = 120
</pre>
		<li>every()</li>
		<pre>
const myAwesomeArray = ["a", "b", "c", "d", "e"]

myAwesomeArray.every(test => test === "d")
//-------> Output : false

const myAwesomeArray2 = ["a", "a", "a", "a", "a"]

myAwesomeArray2.every(test => test === "a")
//-------> Output : true
</pre>
		<li>map()</li>
		<pre>
const myAwesomeArray = [5, 4, 3, 2, 1]
myAwesomeArray.map(x => x * x)

//-------> Output : 25
//                  16
//                  9
//                  4
//                  1
</pre>
		<li>flat()</li>
		<pre>
const myAwesomeArray = [[1, 2], [3, 4], 5]

myAwesomeArray.flat()
//-------> Output : [1, 2, 3, 4, 5]
</pre>
		<li>filter()</li>
		<pre>
const myAwesomeArray = [
  { id: 1, name: "john" },
  { id: 2, name: "Ali" },
  { id: 3, name: "Mass" },
  { id: 4, name: "Mass" },
]

myAwesomeArray.filter(element => element.name === "Mass")
//-------> Output : 0:{id: 3, name: "Mass"},
//                  1:{id: 4, name: "Mass"}
</pre>
		<li>forEach()</li>
		<pre>
const myAwesomeArray = [
  { id: 1, name: "john" },
  { id: 2, name: "Ali" },
  { id: 3, name: "Mass" },
]

myAwesomeArray.forEach(element => console.log(element.name))
//-------> Output : john
//                  Ali
//                  Mass
</pre>
		<li>findIndex()</li>
		<pre>
const myAwesomeArray = [
  { id: 1, name: "john" },
  { id: 2, name: "Ali" },
  { id: 3, name: "Mass" },
]

myAwesomeArray.findIndex(element => element.id === 3)
//-------> Output : 2

myAwesomeArray.findIndex(element => element.id === 7)
//-------> Output : -1
</pre>
		<li>find()</li>
		<pre>
const myAwesomeArray = [
  { id: 1, name: "john" },
  { id: 2, name: "Ali" },
  { id: 3, name: "Mass" },
]

myAwesomeArray.find(element => element.id === 3)
//-------> Output : {id: 3, name: "Mass"}

myAwesomeArray.find(element => element.id === 7)
//-------> Output : undefined
</pre>
		<li>sort()</li>
		<pre>
const myAwesomeArray = [5, 4, 3, 2, 1]

// Sort from smallest to largest
myAwesomeArray.sort((a, b) => a - b)
//-------> Output : [1, 2, 3, 4, 5]

// Sort from largest to smallest
myAwesomeArray.sort((a, b) => b - a)
//-------> Output : [5, 4, 3, 2, 1]
</pre>
		<li>concat()</li>
		<pre>
const myAwesomeArray = [1, 2, 3, 4, 5]
const myAwesomeArray2 = [10, 20, 30, 40, 50]
myAwesomeArray.concat(myAwesomeArray2)
//-------> Output : [1, 2, 3, 4, 5, 10, 20, 30, 40, 50]
</pre>
		<li>fill()</li>
		<pre>
const myAwesomeArray = [1, 2, 3, 4, 5]

// The first argument (0) is the value
// The second argument (1) is the starting index
// The third argument (3) is the ending index
myAwesomeArray.fill(0, 1, 3)
//-------> Output : [1, 0, 0, 4, 5]
</pre>
		<li>includes()</li>
		<pre>
const myAwesomeArray = [1, 2, 3, 4, 5]

myAwesomeArray.includes(3)
//-------> Output : true

myAwesomeArray.includes(8)
//-------> Output : false
</pre>
		<li>reverse()</li>
		<pre>
const myAwesomeArray = ["e", "d", "c", "b", "a"]

myAwesomeArray.reverse()
//-------> Output : ['a', 'b', 'c', 'd', 'e']
</pre>
		<li>flatMap()</li>
		<pre>
const myAwesomeArray = [[1], [2], [3], [4], [5]]

myAwesomeArray.flatMap(arr => arr * 10)
//-------> Output : [10, 20, 30, 40, 50]

// With .flat() and .map()
myAwesomeArray.flat().map(arr => arr * 10)
//-------> Output : [10, 20, 30, 40, 50]
</pre>
	</ol>

	<h2>
		<a href="https://www.codewars.com/kata/search/javascript?q=&r%5B%5D=-8&tags=Arrays&beta=false&order_by=sort_date%20desc">1й уровень сложности</a>
	</h2>

	<ol>


		<li>
			<a href="https://www.codewars.com/kata/572b77262bedd351e9000076/train/javascript">pick a set of first elements (slice)</a>
			<pre>
var arr = ['a', 'b', 'c', 'd', 'e']; 
first(arr, 2) //=> ['a', 'b']
first(arr, 3) //=> ['a', 'b', 'c'];
	</pre>
		</li>


		<li>
			<a href="https://www.codewars.com/kata/576bb71bbbcf0951d5000044">count of positives / sum of negatives</a>
			<pre>
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -11, -12, -13, -14, -15] 
[10, -65]
			</pre>

			<ol>
				<li>если входящее null и пустой массив - вернем []</li>
				<li>создать пару переменных, позитив и негатив</li>
				<li>прогоним цикл</li>
				<li>если входящий элемент массива больше нуля, прибавим к позитиву</li>
				<li>иначе входящий элемент массива меньше нуля, прибавим к негативу</li>
				<li>вернем массив из позитива и негатива</li>
			</ol>
		</li>

		<li>
			<a href="https://www.codewars.com/kata/582e0e592029ea10530009ce/javascript">Duck Duck Goose</a>
			<div>
				<ol>
					<li>вычтем 1 из переданного параметра</li>
					<li>прогоним на остаток через размер массива</li>
					<li>обратимся к этому элементу</li>
				</ol>
			</div>
			<pre>
[$a, $b, $c, $d], 5); // => $a["name"]
			</pre>
		</li>
		<li>
			<a href="https://www.codewars.com/kata/5a34af40e1ce0eb1f5000036/javascript">CSV representation of array (join)</a>
			<pre>
input:
   [[ 0, 1, 2, 3, 4 ],
    [ 10,11,12,13,14 ],
    [ 20,21,22,23,24 ],
    [ 30,31,32,33,34 ]] 
    
output:
     '0,1,2,3,4\n'
    +'10,11,12,13,14\n'
    +'20,21,22,23,24\n'
    +'30,31,32,33,34'
		</pre>
			<ol>
				<li>обращусь к массиву</li>
				<li>разобью по каждому элементу и добавлю в конце '\n'</li>
			</ol>
		</li>
		
		<li>
		<a href="https://www.codewars.com/kata/5b73fe9fb3d9776fbf00009e/train/javascript">Sum of differences in array(sort map reduce) (Math.max(...arr) - Math.min(...arr))</a>
			<pre>
[2, 1, 10]  -->  9
(10 - 2) + (2 - 1) = 8 + 1 = 9
			</pre>
			<ol>
				<li>сортировка с убыванием</li>
				<li>map больший - меньший или 0</li>
				<li>reduce все сложить</li>
			</ol>
		</li>
	</ol>


	<h2>2й уровень сложности</h2>
	<ol>
		<li>
			<div>Реализуйте и экспортируйте функцию getWeekends(), которая возвращает массив из двух элементов – названий выходных дней на английском. Функция принимает на вход параметр – формат возврата. Всего есть два возможных значения:
				'long' (по умолчанию) – вернётся массив, содержащий значения saturday и sunday
				'short' – вернётся массив со значениями sat и sun</div>
			<pre>
expect(getWeekends()).toEqual(['saturday', 'sunday']);
expect(getWeekends('long')).toEqual(['saturday', 'sunday']);
expect(getWeekends('short')).toEqual(['sat', 'sun']);
	</pre>
			<pre class="content">
export const getWeekends = (format) => {
  const longFormat = ['saturday', 'sunday'];
  const shortFormat = ['sat', 'sun'];

  switch (format) {
    case 'long':
      return longFormat;
    case 'short':
      return shortFormat;
    default:
      return longFormat;
  }
};
	</pre>
		</li>
		<li>
			<div>Реализуйте и экспортируйте функцию swap(), которая меняет местами первый и последний элемент массива. Если массив содержит меньше двух элементов, то он возвращается как есть.</div>
			<pre>
swap([]); // []
swap([1]); // [1]
swap([1, 2]); // [2, 1]
swap(['one', 'two', 'three']); // ['three', 'two', 'one']
	</pre>
			<pre class="content">
export const swap = (items) => {
  if (items.length < 2) {
    return items;
  }
  const lastIndex = items.length - 1;
  const last = items[lastIndex];
  items[lastIndex] = items[0];
  items[0] = last;

  return items;
};
	</pre>



		</li>
		<li>
			<div>Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход массив и строковой префикс. Эта функция должна возвращать новый массив, в котором к каждому элементу исходного массива добавляется переданный префикс. Функция предназначена для работы со строковыми элементами. После префикса должен добавляться пробел.</div>
			<pre>

const names = ['john', 'smith', 'karl'];
 
const newNames = addPrefix(names, 'Mr');
console.log(newNames);
// => ['Mr john', 'Mr smith', 'Mr karl'];
 
console.log(names); // Старый массив не меняется!
// => ['john', 'smith', 'karl'];
	</pre>
			<pre class="content">
export default (coll, prefix) => {
  const result = [];

  for (let i = 0; i < coll.length; i += 1) {
    result[i] = `${prefix} ${coll[i]}`;
  }

  return result;
};
	</pre>
		</li>



		</li>
		<li>
			<div>Реализуйте и экспортируйте функцию reverse(), которая принимает на вход массив и располагает элементы исходного массива в обратном порядке. Функция должна мутировать переданный в нее массив - новый массив из нее возвращать не надо.</div>
			<pre>
const names = ['john', 'smith', 'karl'];
 
reverse(names);
console.log(names); // => ['karl', 'smith', 'john']
 
reverse(names);
console.log(names); // => ['john', 'smith', 'karl']

	</pre>
			<pre class="content">
export const reverse = (coll) => {
  const lastIndex = coll.length - 1;
  const middleIndex = lastIndex / 2;

  for (let i = 0; i < middleIndex; i += 1) {
    const mirrorIndex = lastIndex - i;
    const temp = coll[i];
    coll[i] = coll[mirrorIndex];
    coll[mirrorIndex] = temp;
  }
};
	</pre>
		</li>



		</li>
		<li>
			<div>Реализуйте и экспортируйте по умолчанию функцию, которая высчитывает сумму всех элементов массива, которые делятся без остатка на 3 (три).</div>
			<pre>
const coll1 = [8, 9, 21, 19, 18, 22, 7];
calculateSum(coll1); // 48
 
const coll2 = [2, 0, 17, 3, 9, 15, 4];
calculateSum(coll2); // 27
	</pre>
			<pre class="content">
const calculateSum = (coll) => {
  let sum = 0;
  for (let i = 0; i < coll.length; i += 1) {
    const value = coll[i];
    if (value % 3 === 0) {
      sum += value;
    }
  }

  return sum;
};

export default calculateSum;
	</pre>
		</li>



		</li>
		<li>
			<div>Реализуйте и экспортируйте по умолчанию функцию, которая высчитывает среднее арифметическое элементов переданного массива. Благодаря этой функции мы наконец-то посчитаем среднюю температуру по больнице :)</div>
			<pre>
const temperatures1 = [37.5, 34, 39.3, 40, 38.7, 41.5];
calculateAverage(temperatures1); // 38.5
 
const temperatures2 = [36, 37.4, 39, 41, 36.6];
calculateAverage(temperatures2); // 38
	</pre>
			<pre class="content">
export default (coll) => {
  const itemsCount = coll.length;

  if (itemsCount === 0) {
    return null;
  }

  let sum = 0;
  for (const item of coll) {
    sum += item;
  }

  return sum / itemsCount;
};
	</pre>
		</li>



		</li>
		<li>
			<div>Реализуйте функцию getSameParity(), которая принимает на вход массив чисел и возвращает новый, состоящий из элементов, у которых такая же чётность, как и у первого элемента входного массива. Экспортируйте функцию по умолчанию.</div>
			<pre>
getSameParity([]);        // []
getSameParity([1, 2, 3]); // [1, 3]
getSameParity([1, 2, 8]); // [1]
getSameParity([2, 2, 8]); // [2, 2, 8]</pre>
			<pre class="content">
const getSameParity = (coll) => {
  if (coll.length === 0) {
    return [];
  }

  const result = [];
  const remainder = Math.abs(coll[0] % 2);

  for (const item of coll) {
    if (Math.abs(item % 2) === remainder) {
      result.push(item);
    }
  }

  return result;
};

export default getSameParity;
	</pre>
		</li>



		</li>
		<li>
			<div>Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход в виде массива кошелёк с деньгами и название валюты и возвращает сумму денег указанной валюты.

				Реализуйте данную функцию используя управляющие инструкции.

				Параметры функции:

				Массив, содержащий купюры разных валют с различными номиналами
				Наименование валюты</div>
			<pre>
const money1 = [
  'eur 10', 'usd 1', 'usd 10', 'rub 50', 'usd 5',
];
getTotalAmount(money1, 'usd') // 16
 
const money2 = [
  'eur 10', 'usd 1', 'eur 5', 'rub 100', 'eur 20', 'eur 100', 'rub 200',
];
getTotalAmount(money2, 'eur') // 135
 
const money3 = [
  'eur 10', 'rub 50', 'eur 5', 'rub 10', 'rub 10', 'eur 100', 'rub 200',
];
getTotalAmount(money3, 'rub') // 270
	</pre>
			<pre class="content">
const getTotalAmount = (money, currency) => {
  let sum = 0;

  for (const bill of money) {
    const currentCurrency = bill.slice(0, 3);
    if (currentCurrency !== currency) {
      continue;
    }
    const denomination = Number(bill.slice(4));
    sum += denomination;
  }

  return sum;
};

export default getTotalAmount;
	</pre>
		</li>



		</li>
		<li>
			<div>Реализуйте функцию buildDefinitionList(), которая генерирует HTML список определений (теги <dl>, <dt> и
					<dd>) и возвращает получившуюся строку. При отсутствии элементов в массиве функция возвращает пустую строку. Экспортируйте функцию по умолчанию.</div>
			<pre>
const definitions = [
  ['Блямба', 'Выпуклость, утолщения на поверхности чего-либо'],
  ['Бобр', 'Животное из отряда грызунов'],
];
	</pre>
			<pre class="content">
const buildDefinitionList = (definitions) => {
  if (definitions.length === 0) {
    return '';
  }

  const parts = [];

  for (const definition of definitions) {
    const name = definition[0];
    const description = definition[1];
    parts.push(`<dt>${name}</dt><dd>${description}</dd>`);
  }

  const innerValue = parts.join('');
  const result = `<dl>${innerValue}</dl>`;

  return result;
};

export default buildDefinitionList;
	</pre>
		</li>



		</li>
		<li>
			<div>Реализуйте и экспортируйте по умолчанию функцию, которая заменяет каждое вхождение указанных слов в предложении на последовательность $#%! и возвращает полученную строку. Аргументы:

				Текст
				Набор стоп слов
				Словом считается любая непрерывная последовательность символов, включая любые спецсимволы (без пробелов).</div>
			<pre>
const sentence = 'When you play the game of thrones, you win or you die';
const result = makeCensored(sentence, ['die', 'play']);
// When you $#%! the game of thrones, you win or you $#%!
 
const sentence2 = 'chicken chicken? chicken! chicken';
const result2 = makeCensored(sentence2, ['?', 'chicken']);
// '$#%! chicken? chicken! $#%!';
	</pre>
			<pre class="content">
const makeCensored = (text, stopWords) => {
  const words = text.split(' ');

  const result = [];
  for (const word of words) {
    const newWord = stopWords.includes(word) ? '$#%!' : word;
    result.push(newWord);
  }

  return result.join(' ');
};

export default makeCensored;
	</pre>
		</li>



		</li>
		<li>
			<div>Реализуйте и экспортируйте по умолчанию функцию, которая получает на вход строку и считает, сколько символов (без учёта повторяющихся символов) использовано в этой строке. Например, в строке yy используется всего один символ — y. А в строке 111yya! — используется четыре символа: 1, y, a и !.</div>
			<pre>
const text1 = 'yyab'; // y, a, b
countUniqChars(text1); // 3
 
const text2 = 'You know nothing Jon Snow';
countUniqChars(text2); // 13
 
// Если передана пустая строка, то функция должна вернуть `0`
const text3 = '';
countUniqChars(text3); // 0
	</pre>
			<pre class="content">
const countUniqChars = (text) => {
  const uniqChars = [];

  for (const char of text) {
    if (!uniqChars.includes(char)) {
      uniqChars.push(char);
    }
  }

  return uniqChars.length;
};

export default countUniqChars;
	</pre>
		</li>



		</li>
		<li>
			<div>Реализуйте и экспортируйте по умолчанию функцию, которая сортирует массив используя пузырьковую сортировку. Постарайтесь не подглядывать в текст теории и попробуйте воспроизвести алгоритм по памяти.</div>
			<pre>
bubbleSort([]); // []
bubbleSort([3, 10, 4, 3]); // [3, 3, 4, 10]

	</pre>
			<pre class="content">
const bubbleSort = (arr) => {
  let stepsCount = arr.length - 1;
  let swapped;
  do {
    swapped = false;
    for (let i = 0; i &#60; stepsCount; i += 1) {
      if (arr[i] > arr[i + 1]) {
        const temp = arr[i];
        arr[i] = arr[i + 1];
        arr[i + 1] = temp;
        swapped = true;
      }
    }
    stepsCount -= 1;
  } while (swapped);

  return arr;
};

export default bubbleSort;
	</pre>
		</li>



		</li>
		<li>
			<div>Реализуйте и экспортируйте функцию по умолчанию, которая принимает на вход строку, состоящую только из открывающих и закрывающих скобок разных типов, и проверяет, является ли эта строка сбалансированной. Открывающие и закрывающие скобки должны быть одного вида. Пустая строка (отсутствие скобок) считается сбалансированной.

				Строка считается корректной (сбалансированной), если содержащаяся в ней скобочная структура соответствует требованиям:

				Скобки — это парные структуры. У каждой открывающей скобки должна быть соответствующая ей закрывающая скобка.
				Скобки должны закрываться в правильном порядке.</div>
			<pre>
isBracketStructureBalanced('(>');  // false
isBracketStructureBalanced('()');  // true
isBracketStructureBalanced('[()]');  // true
isBracketStructureBalanced('({}[])');  // true
isBracketStructureBalanced('{<>}}'); // false
isBracketStructureBalanced('([)]'); // false
	</pre>
			<pre class="content">
const isOpeningSymbol = (symbol) => openingSymbols.includes(symbol);
const getClosingSymbolFor = (symbol) => closingSymbols[openingSymbols.indexOf(symbol)];

export default (str) => {
  const stack = [];
  for (const symbol of str) {
    if (isOpeningSymbol(symbol)) {
      const closingSymbol = getClosingSymbolFor(symbol);
      stack.push(closingSymbol);
    } else {
      const lastSavedSymbol = stack.pop();
      if (symbol !== lastSavedSymbol) {
        return false;
      }
    }
  }

  return stack.length === 0;
};
	</pre>
		</li>



		</li>
		<li>
			<div>Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход два отсортированных массива и находит их пересечение. Пересечение двух массивов A и B — это массив только с теми элементами A и B, которые одновременно принадлежат обоим массивам, без дублей.</div>
			<pre>
getIntersectionOfSortedArrays([10, 11, 24], [10, 13, 14, 18, 24, 30]); // [10, 24]
 
getIntersectionOfSortedArrays([10, 11, 24], [-2, 3, 4]); // []
 
getIntersectionOfSortedArrays([], [2]); // []
	</pre>
			<pre class="content">
const getIntersectionOfSortedArrays = (arr1, arr2) => {
  const size1 = arr1.length;
  const size2 = arr2.length;

  let i1 = 0;
  let i2 = 0;
  const result = [];

  while (i1 < size1 && i2 < size2) {
    const lastCommon = result[result.length - 1];
    if (arr1[i1] === arr2[i2] && arr1[i1] !== lastCommon) {
      result.push(arr1[i1]);
      i1 += 1;
      i2 += 1;
    } else if (arr1[i1] > arr2[i2]) {
      i2 += 1;
    } else {
      i1 += 1;
    }
  }

  return result;
};

export default getIntersectionOfSortedArrays;
	</pre>
		</li>



		</li>
		<li>
			<div>На многих картах, таких как google maps, реализован поиск мест, находящихся рядом с выбранной точкой, например, с текущим расположением. В этом задании мы реализуем подобную задачу в очень упрощённом варианте.

				location.js
				Реализуйте и экспортируйте функцию getTheNearestLocation(), которая находит ближайшее место к указанной точке на карте и возвращает его. Параметры функции:

				locations – список мест на карте (массив). Каждое место – массив из двух элементов:
				Первый элемент – это название места
				Второй – точка на карте (массив из двух чисел-координат x и y)
				point – текущая точка на карте</div>
			<pre>
const locations = [
  ['Park', [10, 5]],
  ['Sea', [1, 3]],
  ['Museum', [8, 4]],
];
 
const currentPoint = [5, 5];
 
// Если мест нет, то возвращается null
getTheNearestLocation([], currentPoint); // null
 
getTheNearestLocation(locations, currentPoint); // ['Museum', [8, 4]]

	</pre>
			<pre class="content">
export const getTheNearestLocation = (locations, currentPoint) => {
  if (locations.length === 0) {
    return null;
  }

  let [nearestLocation] = locations;
  const [, nearestPoint] = nearestLocation;
  let lowestDistance = getDistance(currentPoint, nearestPoint);

  for (const location of locations) {
    const [, point] = location;
    const distance = getDistance(currentPoint, point);
    if (distance &#60; lowestDistance) {
      lowestDistance = distance;
      nearestLocation = location;
    }
  }

  return nearestLocation;
};
	</pre>
		</li>



		</li>
		<li>
			<div>Реализуйте и экспортируйте функцию getMax(), которая ищет в массиве максимальное значение и возвращает его.</div>
			<pre>
// Для пустого массива возвращается null
getMax([]); // null
getMax([1, 10, 8]); // 10
	</pre>
			<pre class="content">
export const getMax = (coll) => {
  if (coll.length === 0) {
    return null;
  }

  let [max, ...rest] = coll;
  for (const value of rest) {
    if (value > max) {
      max = value;
    }
  }

  return max;
};
	</pre>
		</li>



		</li>
		<li>
			<div>Реализуйте и экспортируйте функцию flatten(). Эта функция принимает на вход массив и выпрямляет его: если элементами массива являются массивы, то flatten сводит всё к одному массиву, раскрывая один уровень вложенности.

				В js эта функция реализована как метод flat() у массивов. Его использовать нельзя.</div>
			<pre>
// Для пустого массива возвращается []
flatten([]); // []
flatten([1, [3, 2], 9]); // [1, 3, 2, 9]
flatten([1, [[2], [3]], [9]]); // [1, [2], [3], 9]
	</pre>
			<pre class="content">
export const flatten = (coll) => {
  let result = [];
  for (const item of coll) {
    if (Array.isArray(item)) {
      result = [...result, ...item];
    } else {
      result = [...result, item];
    }
  }

  return result;
};
	</pre>
		</li>


	</ol>



</body>

</html>
