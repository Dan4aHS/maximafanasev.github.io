<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Title</title>
	<link rel="stylesheet" href="main.css">
</head>

<body>

	<ol>
		<li>Что такое прогрессивный рендеринг?

			<ol>
				<li>Рендеринг на стороне клиента (CSR) - сервер отправляет HTML с пустым body и тегами script, в которых содержатся ссылки на JavaScript-бандлы, с помощью которых браузер будет рендерить контент

					<ol>
						<li>Когда пользователь переходит на веб-страницу, отправляется запрос на получение HTML-документа.</li>
						<li>Сервер отправляет HTML-код с пустым телом и тегами script для загрузки JS-бандлов.</li>
						<li>Браузер анализирует HTML и шлёт HTTP-запросы для получения JS-бандлов. В это время пользователь видит либо часть содержимого HTML, либо пустую страницу, либо индикатор загрузки.</li>
						<li>Только после того как основной JS-бандл получен и отрисован, пользователь видит реальный, значимый контент.</li>
					</ol>
				</li>

				<li>Рендеринг на стороне сервера (происходит быстрее, чем у CSR)

					<ol>
						<li>Браузер запрашивает HTML с сервера.</li>
						<li>Сервер делает API запросы и рендерит HTML-контент на своей стороне.</li>
						<li>Скомпилированный HTML-код отправляется в браузер.</li>
						<li>Как только браузер загружает и анализирует HTML, веб-приложение становится доступным для конечного пользователя, не дожидаясь загрузки JS-бандлов.</li>
						<li>Браузер загружает и запускает JS-бандлы, чтобы сделать страницу интерактивной.</li>
					</ol>

				</li>
				<li>Прогрессивный рендеринг на стороне сервера (последовательного рендеринга частей веб-страницы на стороне сервера и отправки их клиенту по частям)

					<ol>
						<li>Рендер компонента не происходит до тех пор, пока он не появится в поле зрения или не понадобится для взаимодействия с пользователем.</li>
						<li>Загрузка контента при взаимодействии с пользователем (прокрутка) – намного быстрее, чем при CSR или SSR</li>
						<li>Тестирование показывает, что это может сократить время до появления первого интерактивного элемента.</li>
						<li>Впечатления приятнее даже при медленном соединении.</li>
					</ol>
				</li>

				<ol>
					<li>Браузер запрашивает у сервера HTML-код.</li>
					<li>Сервер делает API запросы и сначала рендерит критический контент, а затем отправляет его клиенту.</li>
					<li>Браузер анализирует HTML и отображает его на экране.</li>
					<li>Сервер рендерит некритический контент и передает его браузеру.</li>
					<li>Затем браузер анализирует и отображает некритичный контент.</li>
					<li>Между тем JS-бандлы загружаются и выполняются в фоновом режиме, а браузер передаёт интерактивность элементам DOM.</li>
				</ol>
			</ol>
		</li>
		<li>Прогрессивное web-приложение (progressive web app, PWA) — технология в web-разработке, которая визуально и функционально трансформирует сайт в приложение (мобильное приложение в браузере).</li>
		<li>Кроссбраузерность – это способность веб-ресурса отображаться одинаково хорошо во всех популярных браузерах без перебоев в функционировании и ошибок в верстке, с одинаково корректной читабельностью контента</li>
		<li>Сетевая модель OSI (The Open Systems Interconnection model) — сетевая модель стека (магазина) сетевых протоколов OSI/ISO. Посредством данной модели различные сетевые устройства могут взаимодействовать друг с другом. Модель определяет различные уровни взаимодействия систем. Каждый уровень выполняет определённые функции при таком взаимодействии.</li>
		<li>Поток документа—
			CSS: Позиционирование элементов
			Потоком документа в HTML называется порядок вывода элементов на страницу. В обычном виде все блоки выводятся в том порядке, в котором они записаны внутри HTML-документа.</li>
		<li>Отзывчивый дизайн полагается на изменения шаблона дизайна, чтобы соответствовать доступному пространству. Адаптивный дизайн имеет несколько фиксированных размеров макета и когда сайт определяет пространство, он выбирает макет, наиболее подходящий для экрана.</li>
		<li>Graceful degradation — более широкое понятие, чем progressive enhancement, который ограничен только веб-интерфейсами. Progressive enhancement — это наше, родное, вебовское. Progressive enhancement задает вектор движения (начинай с простого!), а для graceful degradation это не так важно.</li>
		<li>Веб-компоненты — технология, которая позволяет создавать многократно используемые компоненты в веб-документах и веб-приложениях. Веб-компоненты поддерживаются веб-браузерами напрямую и не требуют дополнительных библиотек для работы.</li>
		<li>Мультиязычный сайт — это веб-ресурс, который адаптирован для пользователей из разных стран. Наличие качественно переведенных версий сайта говорит о высоком уровне и целеустремленности компании, ее заботе о пользователях, а также позволяет рассказать о своих преимуществах, технологиях, товарах и услугах широкой аудитории.</li>
		<li>REST (Representational state transfer) – это стиль архитектуры программного обеспечения для распределенных систем, таких как World Wide Web, который, как правило, используется для построения веб-служб. Термин REST был введен в 2000 году Роем Филдингом, одним из авторов HTTP-протокола. Системы, поддерживающие REST, называются RESTful-системами.</li>
		<li>RESTful API — это интерфейс,используемые двумя компьютерными системами для безопасного обмена информацией через Интернет. Большинство бизнес-приложений должны взаимодействовать с другими внутренними и сторонними приложениями для выполнения различных задач. Например, чтобы генерировать ежемесячные платежные ведомости, ваша внутренняя бухгалтерская система должна обмениваться данными с банковской системой вашего клиента, чтобы автоматизировать выставление счетов и взаимодействовать с внутренним приложением по учету рабочего времени. RESTful API поддерживают такой обмен информацией, поскольку они следуют безопасным, надежным и эффективным стандартам программного взаимодействия.</li>
		<li>принципы: Единый интерфейс, Отсутствие сохранения состояния, Многоуровневая система, Емкость кэша, Код по запросу</li>
		<li>Основные уровни модели зрелости Ричардсона? Richardson Maturity Model – это модель, предложенный Леонардом Ричардсоном для оценки зрелости веб службы. Понятия «ребенок», «подросток», «мужчина» и «старик» я сам ввел, чтобы более хорошо представить слоя модели RMM.
			Уровень 1 (Resources(Ресурсы))
			Уровень 2 (HTTP-verbs(http-методы/глаголы))
			Уровень 3 (Hypermedia Controls)</li>
		<li>Критические этапы рендеринга: построение DOM-дерева,
построение CSSOM-дерева,
запуск JavaScript,
создание Render-дерева,
генерация раскладки,
отрисовка.</li>
		<li>Разница между layout, painting и compositing? 1) Layout: расчёт места для объекта на основе правил. 2) Paint: рисовка пикселей для отображения визуальных элементов. 3) Compositing: рисовка слоёв в правильном порядке (правильное наложение и т. д.).</li>
		<li>«Мигание» страницы сайта при медленном интернет подключении.
 
Сначала показывается версия без стилей и стандартным шрифтом.
Затем загружаются стили и веб шрифты — страница обновляется.
 
Методы устранения.
1. Минимальный размер страниц и не использование веб шрифтов.
2. Размещение CSS кода необходимого для отображения «первого экрана» в сам файл HTML.</li>
		<li>History API даёт доступ к управлению историей браузера в рамках текущей сессии. Браузер создаёт новую сессию, когда пользователь открывает новую вкладку или новое окно браузера. С помощью History API можно переходить по истории вперёд, назад и управлять содержимым истории.</li>
		<li>Интернет-хранилище или DOM-хранилище — это программные методы и протоколы веб-приложения, используемые для хранения данных в веб-браузере. Интернет-хранилище представляет собой постоянное хранилище данных, похожее на куки, но со значительно расширенной ёмкостью и без хранения информации в заголовке запроса HTTP.</li>
		<li>Local Storage (локальное хранилище)
Хранит данные бессрочно.
Очищается только с помощью JavaScript или очистки кэша браузера.
Хранит данные объёмом до 5 МБ, это самый большой объём из трёх вариантов хранилища.
Не поддерживается старыми браузерами, например, IE 7 и ниже.
Работает по правилу ограничения домена (same origin policy). То есть сохранённые данные доступны только для одного источника.
Session Storage (сессионное хранилище)
Хранит данные, пока продолжается текущая сессия. Когда пользователь закрывает браузер, данные становятся недоступными.
Используется контекст браузера верхнего уровня, поэтому каждая вкладка браузера хранит уникальные данные.
Объём данных больше чем в Cookie.
Не поддерживается старыми браузерами, например, IE 7 и ниже.
Cookie
Хранит данные, которые можно передавать на сервер через заголовки.
Локальное и сессионное хранилище доступны только на клиентской стороне.
Срок хранения устанавливается при создании cookie.
Объём данных не превышает 4 Кбайт.
Cookie могут быть защищёнными, в этом случае их содержимое нельзя получить на стороне клиента. Это важно для аутентификации при хранении пользовательских токенов.</li>
		<li>Способы уменьшения времени загрузки веб-страницы? Уменьшите количество HTTP-запросов
Помещайте CSS файлы в начале страницы
Помещайте javascript в конец страницы
Минимизируйте css и javascript.
Минимизация файла — это удаление из кода всех несущественных символов с целью уменьшения объема файла и ускорения его загрузки. ...
Используйте кэш браузера</li>
		<li>Core Web Vitals — это группа новых факторов ранжирования Google, которые запускаются в мае 2021 года. В эту группу входят 3 параметра: LCP (Largest Contentful Paint) — скорость загрузки основного контента. Основной контент — это самый большой элемент на странице: текст, видео,</li>
		<li>Расскажите о метриках Core Web Vitals? LCP (Largest Contentful Paint) — скорость загрузки основного контента веб-страницы. Основной контент — это самый большой элемент на странице: текст, видео, картинка. Гугл сравнивает разницу между загрузкой основного контента и остальных элементов веб-страницы.

FID (First Input Delay) — время ожидания до начала взаимодействия пользователя с сайтом. Чем дольше пользователю приходится ждать момента, когда можно начать взаимодействовать со страницей (скролить, кликать по ссылкам, наживать на кнопки) тем ниже лидогенерация и выше показатель отказов.

CLS (Cumulative Layout Shift) — устойчивость верстки и элементов, которые мешают пользователю взаимодействовать с сайтом. Если в процессе загрузки элементы, особенно кликабельные, смещаются по экрану, пользователь может нажать не на ту кнопку, что не понравится ни пользователю, ни Google.</li>
		<li>Разница между preload, prefetch, preconnect и prerender?
		<ol>
			<li>link rel= "preload" говорит браузеру как можно скорее загрузить и кэшировать ресурс (например, скрипт или таблицу стилей). Это полезно, когда ресурс понадобится через несколько секунд после загрузки страницы — и вы хотите ускорить процесс.

Браузер ничего не делает с ресурсом после загрузки. Скрипты не выполняются, таблицы стилей не применяются. Ресурс просто кэшируется и немедленно предоставляется по запросу.</li>
			<li>link rel= "prefetch" просит браузер загрузить и кэшировать ресурс (например, скрипт или таблицу стилей) в фоновом режиме. Загрузка происходит с низким приоритетом, поэтому не мешает более важным ресурсам. Это полезно, если ресурс понадобится на следующей странице, а вы хотите заранее его кэшировать.
</li>
			<li>link rel= "preconnect" просит браузер заранее подключиться к домену, когда вы хотите ускорить установку соединения в будущем.</li>
			<li>link rel= "dns-prefetch" просит браузер заранее выполнить резолвинг DNS для домена, если вы скоро будете подключаться к нему и хотите ускорить начальное соединение.</li>
		</ol>
		</li>
		<li>PRPL — это паттерн, рекомендуемый командой разработчиков Chrome для организации поэтапной загрузки кода. Он рассчитан на то, чтобы приложения, использующие его, как можно быстрее становились бы интерактивными на дешёвых устройствах и в медленных сетях. Паттерн PRPL поощряет предварительную загрузку минимального объёма JS-кода, необходимого для того, чтобы со страницей можно было бы работать. Затем ресурсы загружаются с использованием методик ленивой загрузки. Если нужно — можно воспользоваться сервис-воркером для предварительного кэширования JavaScript-ресурсов, необходимых для будущих взаимодействий с сайтом.</li>
	</ol>

</body>

</html>
